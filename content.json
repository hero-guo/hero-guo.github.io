{"meta":{"title":"Neil's site","subtitle":"A bird is known by its note, and a man by his talk.","description":"javascript nodejs react","author":"Neil Guo","url":"http://hero-guo.com"},"pages":[{"title":"简介","date":"2016-11-22T03:52:49.000Z","updated":"2016-12-11T09:06:42.000Z","comments":true,"path":"about/index.html","permalink":"http://hero-guo.com/about/index.html","excerpt":"","text":"名字： Neil Guo 职业：前端工程师 联系方式： handsamechina@126.com 线上简历"}],"posts":[{"title":"JavaScript事件循环探索","slug":"javascript事件循环探索","date":"2018-07-11T13:28:57.000Z","updated":"2018-07-11T15:28:06.687Z","comments":true,"path":"2018/07/11/javascript事件循环探索/","link":"","permalink":"http://hero-guo.com/2018/07/11/javascript事件循环探索/","excerpt":"","text":"一直对js的事件循环不是很清晰，最近看了JavaScript忍者秘籍的第13章后，有了一些感悟，特此总结一下，分享给大家。 单线程众所周知，JavaScript是单线程执行模型，同一时刻只能执行一个代码片段，一个任务开始后知道运行完成，不会被其他任务中断。当一个任务花费的时间很长的话，用户就会明显的感觉到卡顿。浏览器为了解决这个问题引入了事件循环的概念（Event Loop）。 事件循环事件循环具有至少两个队列处理任务。任务分为两类，宏任务（macro-task）和微任务（micro-task）。 宏任务代表一个个离散、独立的工作单元，运行完之后，浏览器可以继续其他的调度。包括：创建文档对象，解析HTML，执行JavaScript，以及各种事件…… 微任务是更小的任务，主要用户更新应用程序的状态，必须在浏览器任务继续执行其他任务之前执行。微任务需要尽可能快地通过异步方式执行，同时不能产生全新的微任务。包括promise、回调函数、DOM发生变化…… 仅包含宏任务123// 主线程JavaScript运行15msbtn1.addEventListener('click', function() &#123;运行 8ms&#125;, false);btn2.addEventListener('click', function() &#123;运行 5ms&#125;, false); ​ 现在假设主线程运行15ms， 在第5ms单击btn1，在第12ms的时候单击btn2。基于单线程执行模型，单击按钮之后不会立即执行对应的处理函数，因为一个任务一旦开始就不会被另一个任务中断。因此，在主线程执行的15ms期间，按钮的单击处理函数放入队列。当主线程执行完成也就是15ms之后，程序开始处理微任务，因为当前不存在微任务，跳过此步骤，开始执行更新UI。 ​ 之后进入第二次循环，也就是开始执行btn1的处理函数，需要运行8ms，btn2处理函数在队列中等待。当btn1处理函数执行完之后，浏览器检查微任务是否存在和是否更新UI，删除任务队列里的btn1的处理函数。 ​ 最后进入第三次循环，开始执行btn2的处理函数，需要运行5ms，处理函数执行完之后，检查微任务和是否需要更新UI，删除任务队列里的btn2的处理函数，最终任务队列为空，循环结束。 同时含有宏任务和微任务12345678// 主线程JavaScript运行15msbtn1.addEventListener('click', function() &#123; Promise.resolve().then(() =&gt; &#123; 运行 4ms &#125;); 运行 8ms &#125;, false);btn2.addEventListener('click', function() &#123;运行 5ms&#125;, false); 本例中在btn1的事件处理函数里增加了一个立即兑现的Promise，需要运行4ms。 现在代码的执行顺序为： 1. 主线程执行15ms，在5ms和12ms的时候分别将处理函数放入任务队列，更新UI。 2. 15m后处理btn1事件处理函数，发现Promise，放入微任务队列，btn1事件处理函数继续执行8ms，检查微任务队列发现有Promise回调函数，然后开始执行Promise回调函数，运行4ms，继续检查微任务队列，如果为空，检查是否需要更新UI，进入下一轮循环。 3. 处理btn2的事件处理函数…… 计时器基于上面的事件循环机制，现在我们来看一种特殊类型的事件：计时器。浏览器提供了两种创建计时器的方法 setTimeout 和 setInterval。 他们都挂载在 window 对象上。 setTimeout：在指定的延迟时间结束时执行一次回调函数，返回标识计时器的唯一值，可用于取消定时器（clearTimeout(id)）。 setInterval：按照指定的延迟间隔不断的执行回调函数，返回标识计时器的唯一值，可用于取消定时器（clearInterval(id)）。 事件循环中的定时器12345678// 主线程JavaScript运行18mssetTimeout(function() &#123; 运行6ms;&#125;, 10);setInterval(function() &#123; 运行8ms;&#125;, 10);btn1.addEventListener('click', function() &#123;运行 10ms&#125;, false); 👆代码的执行过程是什么呢？ 现在我们想象一下主线程代码需要运行18ms，在第6ms的时候用户点击了按钮，在第10ms延迟计时器到期，间隔计时器第一次触发。 我们知道一个任务一旦开始执行，就无法被其他任务中断。所以，6ms将事件处理函数加入队列，10ms分别将延迟计时器和间隔计时器回调放入队列。运行到18m主线程执行完毕，检查微任务队列和更新UI，进入下一个时间循环。开始执行btn1事件回调，运行10ms，这时候在btn1事件回调运行的过程中，间隔计时器第二次到期，但是任务队列里面已经有一个间隔计时器处理函数，所以忽略这个处理函数。btn1事件回调运行结束，检查微任务队列和更新UI，进入下一个事件循环。开始执行延迟计时器处理函数，运行6ms，在这个过程中间隔计时器第三次到期，但是由于任务队列已经有了处理函数，继续忽略。延迟计时器处理函数运行完毕，检查微任务队列和更新UI，进入下一个事件循环。现在开始执行间隔计时器处理函数，运行8ms，在这期间间隔计时器第四次到期，这时候任务队列里没有处理函数，所以将这次的处理函数放入任务队列，间隔定时器处理函数运行完成，检查微任务队列和更新UI，进入下一个事件循环，然后重复运行间隔定时器…… 通过以上的执行过程我们发现，我们只能控制计时器何时被加入队列，而无法控制何时执行。 最后，JavaScript的事件循环是这门语言非常重要的基础，由于我水平有限以上只是简单总结了一下它的执行过程。大家可以深入研究一下Nodejs的事件循环 ​","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"事件循环","slug":"事件循环","permalink":"http://hero-guo.com/tags/事件循环/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"扩展原生Number","slug":"扩展原生Number","date":"2018-02-05T14:46:27.000Z","updated":"2018-02-05T14:52:50.457Z","comments":true,"path":"2018/02/05/扩展原生Number/","link":"","permalink":"http://hero-guo.com/2018/02/05/扩展原生Number/","excerpt":"","text":"今天看你不知道的js 第三章有个比较有意思的方法，特记录一下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647if (!Number.prototype[Symbol.iterator]) &#123; Object.defineProperty( Number.prototype, Symbol.iterator, &#123; writable: true, configurable: true, enumerable: false, value: function iterator()&#123; var i, inc, done = false, top = +this; // iterate positively or negatively? inc = 1 * (top &lt; 0 ? -1 : 1); return &#123; // make the iterator itself an iterable! [Symbol.iterator]()&#123; return this; &#125;, next() &#123; if (!done) &#123; // initial iteration always 0 if (i == null) &#123; i = 0; &#125; // iterating positively else if (top &gt;= 0) &#123; i = Math.min(top,i + inc); &#125; // iterating negatively else &#123; i = Math.max(top,i + inc); &#125; // done after this iteration? if (i == top) done = true; return &#123; value: i, done: false &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; &#125;; &#125; &#125; );&#125; 用法123456for (var i of 3) &#123; console.log( i );&#125;// 0 1 2 3[...-3]; // [0,-1,-2,-3]","categories":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://hero-guo.com/tags/ES6/"}],"keywords":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}]},{"title":"使用commitlint规范git提交","slug":"使用commitlint规范git提交","date":"2018-02-05T14:06:11.000Z","updated":"2018-02-05T14:13:28.413Z","comments":true,"path":"2018/02/05/使用commitlint规范git提交/","link":"","permalink":"http://hero-guo.com/2018/02/05/使用commitlint规范git提交/","excerpt":"","text":"commitlint: git 提交信息规范与验证 husky: 使ghook更容易 standard-version: 自动生成CHANGELOG 并发布版本 安装 123npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;npm i --save-dev standard-versionnpm install husky --save-dev 配置 commitlint 123456789101112echo &quot;module.exports = &#123;extends: [&apos;@commitlint/config-conventional&apos;]&#125;&quot; &gt; commitlint.config.js// commitlint.config.js module.exports = &#123; extends: [&apos;@commitlint/config-conventional&apos;], rules: &#123; &apos;type-enum&apos;: [2, &apos;always&apos;, [ &quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;perf&quot;, &quot;test&quot;, &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;revert&quot; ]], &apos;scope-empty&apos;: [2, &apos;never&apos;], &apos;subject-full-stop&apos;: [0, &apos;never&apos;], &apos;subject-case&apos;: [0, &apos;never&apos;] &#125;&#125;; tandard-version 和 husky 123456789101112// package.json &quot;scripts&quot;: &#123; &quot;lint&quot;: &quot;eslint .&quot;, &quot;commitmsg&quot;: &quot;commitlint -e $GIT_PARAMS&quot;, &quot;release&quot;: &quot;standard-version&quot;, &quot;validate&quot;: &quot;npm prune&quot;, &quot;pre-commit&quot;: &quot;npm run lint&quot;, &quot;pre-push&quot;: &quot;npm run validate&quot;, &quot;npmi&quot;: &quot;npm i&quot;, &quot;post-merge&quot;: &quot;npm run npmi&quot;, &quot;post-rewrite&quot;: &quot;npm run npmi&quot; &#125;","categories":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"git","slug":"git","permalink":"http://hero-guo.com/tags/git/"}],"keywords":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}]},{"title":"前端发展史","slug":"前端发展史","date":"2017-12-17T07:04:20.000Z","updated":"2017-12-17T06:38:50.667Z","comments":true,"path":"2017/12/17/前端发展史/","link":"","permalink":"http://hero-guo.com/2017/12/17/前端发展史/","excerpt":"","text":"什么是前端前端工程师主要利用HMTL与CSS构建页面，用JavaScript完善交互以及用户体验。 诞生 1994年可以看做前端历史的起点，这一年10月13日网景推出了第一版Navigator；这一年，Tim Berners-Lee创建了W3C；这一年，Tim的基友发布了CSS（层叠样式表）。1995年，当时在网景公司就职的布兰登·艾克正为Netscape Navigator 2.0浏览器开发的一门名为LiveScript的脚本语言，后来网景公司与昇阳电脑公司组成的开发联盟为了让这门语言搭上java这个编程语言“热词”，将其临时改名为“JavaScript”，日后这成为大众对这门语言有诸多误解的原因之一。 万维网（WWW）是欧洲核子研究组织的一帮科学家为了方便看文档、传论文而创造的，这就是为什么Web网页都基于Document。Document就是用标记语言+超链接写成的由文字和图片构成的HTML页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和Document一样，完全基于HTML页面，并且所有内容都是静态的。 1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。 2006年，XMLHttpRequest被W3C正式纳入标准。 至此，早期的Document终于进化为了Web page，上述三个局限都得到了妥善的解决。 远古时代（web 1.0）那时候的web开发还属于纯静态开发。开发者在web服务器的指定文件夹(/www)下，放置一下html文件，当浏览器请求的页面的时候返回相应的html文件。 但是，渐渐的纯静态的页面不足以满足产品的发展需求（例如：统计该网站的访问流量，提交用户的输入信息）。这时候，大约2005年左右，出现了Java Server Pages(JSP)，微软的ASP，以及Ajax！你可以基于jsp和Ajax快速构建一个可伸缩并且安全的应用程序。 石器时代 (web 2.0)因为当时浏览器厂商的混乱（例如：ie, chrome, firefox等），拥有不同内核的浏览器Trident(IE内核)，Gecko(Firefox 内核)，webkit（Safari 内涵）, Chromium/Blink（Chrome内核），Presto（Opera内核）等。当时的浏览器厂商的标准都不一样。比如写一个点击事件需要做一些兼容性处理。 1var e = e || window.event //处理ie浏览器和其他浏览器之间的事件兼容问题 这时候为了处理浏览器的兼容性，出现了YUI 和 jQuery, 主要解决了DOM元素选择，CSS操纵，事件系统处理。同时也可以兼顾一下动画效果的实现和一些常用插件的封装（表单验证，日历插件等）。 12345678910//jQuery$(\"p.surprise\").addClass(\"ohmy\").show(\"slow\");$(\"p.surprise\").on(\"click\", function (e) &#123; console.log(e.target);&#125;);//YUIYUI().use('node', 'event', function (Y) &#123; // The Node and Event modules are loaded and ready to use. // Your code goes here!&#125;); 模块化时代最开始JavaScript承担的任务量并不多，表单验证基本上就是他的全部，最多就是简短的前端交互，这个时期JavaScript组织结构非常凌乱，大部分都是后端顺手代劳，那时候还没有“前端”这一职位。 一般都是写到一个文件或者直接写到jsp、asp的后端模板页面上就完事了。随着ajax的流行，前端能做的东西一夜之间暴涨，代码量飞速增加，单文件维护代码已经太沉重，多人开发全局变量泛滥，代码合并引起冲突覆盖等问题。最开始的解决的方式是用匿名函数包裹自己的代码，这样就不会把定义的变量暴露到全局作用域里面。 12345678910111213141516//立即执行函数写法 var module1 = (function()&#123; var m1 = function()&#123; //业务代码 &#125;; return &#123; m1 : m1 &#125;; &#125;)();//可以传入参数var module1 = (function ($, undefined) &#123; //业务代码&#125;)(jQuery);//命名空间方式var namespace = &#123;&#125;;namespace.xxx = function () &#123;...&#125; 随着网站逐渐的发展，嵌入网页的Javascript代码越来越庞大，而网页越来越像桌面程序，需要一个团队去分工协作，进行管理和测试等等，为了更好的管理网页的业务逻辑，处理代码之间的依赖关系，产生了模块化编程的理念。 2008年9月2日，Google为旗下浏览器Chrome加入了V8 JavaScript处理引擎，可以更快速，更稳定，更安全的处理JavaScript代码。2009年，Ryan Dahl结合Google的 V8引擎、事件驱动模式、低级I\\O接口开发了Node.js。 2010年1月，一款名为’npm‘的软件包管理系统诞生，随之而来的还有commonJS 规范。 模块的标识应遵循的规则（书写规范） 定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API 如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖 如果引入模块失败，那么require函数应该报一个异常 模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。 1234567891011//math.jsexports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;;//add.jsvar add = require('math').add;add(val, 1); 但是Node.js主要是用于服务器端，无法直接用在浏览器端，主要表现在服务端require一个模块，直接就从硬盘或者内存中读取了，消耗的时间可以忽略。而浏览器则不同，需要从服务端来下载这个文件，然后运行里面的代码才能得到API，需要花费一个http请求，也就是说，require后面的一行代码，需要资源请求完成才能执行。由于浏览器端是以插入&lt;script&gt;标签的形式来加载资源的（ajax方式不行，有跨域问题），没办法让代码同步执行，所以像commonjs那样的写法会直接报错。 所以，社区意识到，要想在浏览器环境中也能模块化，需要对规范进行升级。而就在社区讨论制定下一版规范的时候，内部发生了比较大的分歧，产生了不同的规范。 AMD/RequireJs的崛起与妥协 用全局函数define来定义模块，用法为：define(id?, dependencies?, factory); id为模块标识，遵从CommonJS Module Identifiers规范 dependencies为依赖的模块数组，在factory中需传入形参与之一一对应 如果dependencies的值中有”require”、”exports”或”module”，则与commonjs中的实现保持一致 如果dependencies省略不写，则默认为[“require”, “exports”, “module”]，factory中也会默认传入require,exports,module 如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx 如果factory为对象，则该对象即为模块的返回值 12345678910111213141516//页面中需要引入require.js//data-main 的作用是告诉 require.js 加载 main.js的代码.// &lt;script data-main=\"scripts/main\" src=\"scripts/require.js\"&gt;&lt;/script&gt;// math.jsdefine(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;;&#125;);//main.jsrequire(['math'], function (math)&#123; math.add(1,1);&#125;); 兼容并包的CMD/seajsseajs的作者是国内大牛, 淘宝前端玉伯。 一个文件一个模块，所以经常就用文件名作为模块id CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写 factory是一个函数，有三个参数，function(require, exports, module) require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id) exports 是一个对象，用来向外提供模块接口 module 是一个对象，上面存储了与当前模块相关联的一些属性和方法 123456789101112&lt;script src=\"sea.js\" data-main=\"main.js\"&gt;&lt;/script&gt;//main.jsseajs.use(['./hello', 'jquery'], function(hello, $) &#123; $('#beautiful-sea').click(hello.sayHello);&#125;);//hellodefine(function(require, exports, module) &#123; var $ = require('jquery'); exports.sayHello = function() &#123; $('#hello').toggle('slow'); &#125;;&#125;); AMD与CMD区别主要是： AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块 CMD推崇就近依赖，只有在用到某个模块的时候再去require 面向未来的ES6模块标准ECMAScript是由ECMA-262标准化的脚本语言的名称。JavaScript和JScript与ECMAScript兼容，但包含超出ECMAScript的功能。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。 2011 年，ECMAScript 5.1(ES5) 版发布。也是前端快速发展的一段时间。上面大部分模块解决方案，jQuery等框架都是基于ECMAScript 5.1规范开发的。2015 年，负责制定 ECMAScript 规范草案的委员会决定将定义新标准的制度改为一年一次。ES6的第一个版本在2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015/ES6），2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016/ES7），2017年6月，《ECMAScript 2017 标准》（简称 ES2017/ES8）。我们统一把ECMAScript 2015标准之后的版本称为ES6. 模块功能主要由两个命令构成：export 和 import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 1234567//math.jsexport function add(x, y) &#123; return x+y;&#125;//app.jsimport &#123;add&#125; from './math';add(1, 2) 但是由于ES6的标准太超前，浏览器的更新无法跟上，所以还不能直接应用到浏览器里面。通过Babel 语法转换器在本地编译成浏览器可识别的ES5代码。 未来前端发展到模块化时代变得越来正规，团队之间的配合也越来越重，遇到的问题越来越多，通过借鉴传统的后端开发模式，衍生出了自己的JavaScript设计模式（单例模式，观察者模式，原型模式等），也有了自己的架构模式（MVC，MVVM，MVP）。 根据不同的设计模式有出现了不同的前端框架(Ext JS, jQuery UI, jQuery Mobile, Dojo, Prototype JS, Kissy, React, Vue, Angular等) 。 既然JavaScript出现了各种不同的模块解决方案，CSS也需要跟上JavaScript模块化进程（Sass, Less, Stylus）。 HTML也出现了各种模版系统（Handlebars，EJS等）。 各种编译工具（grunt, gulp, webpack等）。 最后, 我们期待无法预测的未来。 It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only. 那是最好的時代，那是最壞的時代；那是智慧的歲月，那是愚昧的歲月；那是信任的紀元，那是懷疑的紀元；那是光明的季節，那是黑暗的季節；那是希望的春天，那是失望的冬天；我們的前面曾應有盡有，我們的前面曾一無所有；我們都將走上天堂，我們都將走向另一端–簡言之，那段時期與現在的時期是那麼相似，那些最吵雜的權威人士都堅持，不論是善良或邪惡，用最高級形容詞來評論。","categories":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"}],"keywords":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}]},{"title":"数据去重","slug":"arr-uniq","date":"2017-11-05T16:00:00.000Z","updated":"2017-11-06T09:29:17.000Z","comments":true,"path":"2017/11/06/arr-uniq/","link":"","permalink":"http://hero-guo.com/2017/11/06/arr-uniq/","excerpt":"只包含原始变量, 不会判断值的类型","text":"只包含原始变量, 不会判断值的类型 12345const array = [ 1, 1, 'a', 'a' ];function uniq(arr) &#123; return arr.filter((v, i) =&gt; arr.indexOf(v) === i);&#125;console.log(uniq(array)); //=&gt; [1, 'a'] 123456const array = [ 1, 1, 'a', 'a' ];function uniq(arr) &#123; return Array.from(new Set(arr));//return [...new Set(arr)]; &#125;console.log(uniq(array)); //=&gt; [1, 'a'] 12345678910const array = [ 1, 1, 'a', 'a' ];function uniq(arr) &#123; const res = []; const len = arr.length; for (let i = 0; i &lt; len; i++) &#123; if (!~res.indexOf(arr[i])) res.push(arr[i]); &#125; return res;&#125;console.log(uniq(array)); //=&gt; [1, 'a'] 包含引用类型12345678910const array = [&#123; a: 1 &#125;, &#123; a: 1 &#125;, [ 1, 2 ], [ 1, 2 ]];function uniq(arr) &#123; const hash = &#123;&#125;; return arr.filter(v =&gt; &#123; const key = JSON.stringify(v); const bool = !!hash[key]; return bool ? false : hash[key] = true; &#125;);&#125;console.log(uniq(array)); //=&gt; [&#123; a: 1 &#125;, [ 1, 2 ]]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"数据去重","slug":"数据去重","permalink":"http://hero-guo.com/tags/数据去重/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"JavaScript数据结构与算法 —— 栈","slug":"javascript-——-栈","date":"2017-09-09T07:04:20.000Z","updated":"2018-07-11T13:37:05.847Z","comments":true,"path":"2017/09/09/javascript-——-栈/","link":"","permalink":"http://hero-guo.com/2017/09/09/javascript-——-栈/","excerpt":"","text":"最近看了一本《学习JavaScript数据结构与算法》，想把里面介绍的一些数据结构和算法记录下来，加深印象。 栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾。称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，就元素都接近栈底。 在JavaScript里面数组的一些方法可以很好的模拟栈。12345678910111213141516171819202122232425262728293031323334353637/** *用JavaScript数组模拟栈 *@class Stack *@constructor *@method ** push(element) 添加一个或多个新元素到栈顶 ** pop() 移除栈顶的元素，同时返回被移除的新元素 ** peek() 返回栈顶元素，不对栈做任何修改 ** isEmpty() 返回ture(栈为空) 和 false(非空) ** clear() 移除栈里的所有元素 ** size() 返回栈里元素的个数 ** print() 输出栈**/function Stack() &#123; var items = []; //保存栈里的元素 this.push = function(element) &#123; items.push(element); &#125; this.pop = function() &#123; return items.pop(); &#125; this.peek = function() &#123; return items[items.length - 1]; &#125; this.isEmpty = function() &#123; return !items.length; &#125; this.clear = function() &#123; items = []; &#125; this.size = function() &#123; return items.length; &#125; this.print = function() &#123; console.log(items.toString()); &#125;&#125; 以上就是一个栈的实现。现在我们来看看怎么使用它。12345678910111213141516var stack = new Stack();//往栈里添加些元素stack.push(3);stack.push(4);//调用方法console.log(stack.isEmpty()); // =&gt; falseconsole.log(stack.size()); // =&gt; 2console.log(stack.peek()); // =&gt; 4console.log(stack.print()); // =&gt; '3,4'stack.pop();console.log(stack.print()); // =&gt; 3stack.clear()console.log(stack.isEmpty()); // =&gt; trueconsole.log(stack.print()); // =&gt; '' 实际应用进制转换12345678910111213141516171819function baseConverter(num, base) &#123; var stack = new Stack(), base = base || 2, rem, digits = '0123456789ABCDEF', baseString = ''; while (num &gt; 0) &#123; rem = Math.floor(num % base); stack.push(rem); num = Math.floor(num / base); &#125; while (!stack.isEmpty()) &#123; baseString += digits[stack.pop()]; &#125; return baseString;&#125;console.log(baseConverter(100)); //=&gt; 1100100console.log(baseConverter(100, 8)); //=&gt; 144console.log(baseConverter(100, 16)); //=&gt; 64","categories":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://hero-guo.com/tags/数据结构与算法/"}],"keywords":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}]},{"title":"JavaScript 面向对象","slug":"JavaScript-面向对象","date":"2017-04-11T03:05:34.000Z","updated":"2017-08-30T14:28:05.000Z","comments":true,"path":"2017/04/11/JavaScript-面向对象/","link":"","permalink":"http://hero-guo.com/2017/04/11/JavaScript-面向对象/","excerpt":"构造函数构造函数也是一个函数，通过new运算符可以生成一份实例同时把this绑定到实例上。JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。12345678910111213function Vehicle (engines) &#123; this.engines = engines; &#125; Vehicle.prototype.drive = function() &#123; console.log(`engines=&gt;$&#123;this.engines&#125;`); &#125; //实例 var car1 = new Vehicle(1); var car2 = new Vehicle(2); car1.drive(); //=&gt; engines=&gt;1 car2.drive(); //=&gt; engines=&gt;2 console.log(car1.constructor === Vehicle); //true console.log(car2.constructor === Vehicle); //true","text":"构造函数构造函数也是一个函数，通过new运算符可以生成一份实例同时把this绑定到实例上。JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。12345678910111213function Vehicle (engines) &#123; this.engines = engines; &#125; Vehicle.prototype.drive = function() &#123; console.log(`engines=&gt;$&#123;this.engines&#125;`); &#125; //实例 var car1 = new Vehicle(1); var car2 = new Vehicle(2); car1.drive(); //=&gt; engines=&gt;1 car2.drive(); //=&gt; engines=&gt;2 console.log(car1.constructor === Vehicle); //true console.log(car2.constructor === Vehicle); //true instanceof是一个操作符，可以判断对象是否为某个类型的实例12console.log(car1 instanceof Vehicle); //trueconsole.log(car2 instanceof Vehicle); //true instanceof判断的是对象11 instanceof Number //false isPrototypeOf用来判断proptotype对象和实例之间的关系12console.log(Vehicle.prototype.isPrototypeOf(car1)); //true console.log(Vehicle.prototype.isPrototypeOf(car2)); //true hasOwnProperty()可以判断一个对象是否包含自定义属性而不是原型链上的属性12console.log(car1.hasOwnProperty('engines')); //true console.log(car1.hasOwnProperty('drive')); //false","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"promise.all错误处理","slug":"promise-all","date":"2017-03-13T13:15:15.000Z","updated":"2017-08-30T15:38:19.000Z","comments":true,"path":"2017/03/13/promise-all/","link":"","permalink":"http://hero-guo.com/2017/03/13/promise-all/","excerpt":"通常处理多个请求的时候我们会用Promise.all()方法。该方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。但是当其中任何一个被拒绝的话。主Promise.all([..])就会立即被拒绝，并丢弃来自其他所有promis的全部结果。","text":"通常处理多个请求的时候我们会用Promise.all()方法。该方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。但是当其中任何一个被拒绝的话。主Promise.all([..])就会立即被拒绝，并丢弃来自其他所有promis的全部结果。1234567891011var p1 = Promise.resolve(3);var p2 = Promise.reject(2);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, \"foo\");&#125;); Promise.all([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // 永远走不到这里&#125;).catch(function(err) &#123; console.log(err); // 2&#125;); 这不是我们想要的。所以在使用这个方法的时候要记住为每个promise关联一个错误的处理函数1234567891011121314151617var p1 = Promise.resolve(3).catch(function(err) &#123; return err;&#125;);var p2 = Promise.reject(2).catch(function(err) &#123; return err;&#125;);var p3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, \"foo\");&#125;).catch(function(err) &#123; return err;&#125;); Promise.all([p1, p2, p3]).then(values =&gt; &#123; console.log(values); // [3, 2, \"foo\"]&#125;).catch(function(err) &#123; console.log(1); //不会走到这里&#125;);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"函数柯里化","slug":"curry","date":"2017-02-27T03:27:55.000Z","updated":"2017-08-30T14:28:05.000Z","comments":true,"path":"2017/02/27/curry/","link":"","permalink":"http://hero-guo.com/2017/02/27/curry/","excerpt":"函数柯里化定义柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 函数柯理化实现","text":"函数柯里化定义柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。 函数柯理化实现 1234567891011121314151617181920212223242526var autocurry = function (fn) &#123; var numargs = fn.length; return createRecurser([]); function createRecurser (acc) &#123; return function () &#123; var args = [].slice.call(arguments); return recurse(acc, args); &#125;; &#125; function recurse (acc, args) &#123; var newacc = acc.concat(args); if (newacc.length &lt; numargs) &#123; return createRecurser(newacc); &#125; else &#123; return fn.apply(this, newacc); &#125; &#125;&#125;var add = autocurry(function (a,b) &#123; return a + b;&#125;);console.log(add(1,2)); =&gt; 3console.log(add(1)(3)); =&gt; 4","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"柯里化","slug":"柯里化","permalink":"http://hero-guo.com/tags/柯里化/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"JavaScript 事件详解","slug":"javascript-event","date":"2017-02-13T03:17:33.000Z","updated":"2018-07-11T13:37:09.254Z","comments":true,"path":"2017/02/13/javascript-event/","link":"","permalink":"http://hero-guo.com/2017/02/13/javascript-event/","excerpt":"事件冒泡与捕获 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。IE 5.5: div -&gt; body -&gt; documentIE 6.0: div -&gt; body -&gt; html -&gt; documentMozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。","text":"事件冒泡与捕获 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。IE 5.5: div -&gt; body -&gt; documentIE 6.0: div -&gt; body -&gt; html -&gt; documentMozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。 123&lt;div&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 这两个元素都绑定了click事件，如果用户点击了p，它在div和p上都触发了click事件，那这两个事件处理程序哪个先执行呢？事件顺序是什么？ 事件捕获当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 事件冒泡当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 W3C模型W3C模型是将两者进行中和，在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。 程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，type, listener[, options]。第一个参数表示监听事件类型的字符串。第二个参数当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡ele.addEventListener(‘click’,doSomething,true)true=捕获false=冒泡 IEIE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。1ele.attachEvent(\"onclick\", doSomething); 事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。 至此我们可以封装一下事件绑定的方法：1234567891011121314151617181920//事件绑定function addEvent(target, type, func) &#123; if (target.addEventListener) &#123; target.addEventListener(type, func, false); &#125; else if (target.attachEvent) &#123; target.attachEvent('on' + type, func); &#125; else &#123; target['on' + type] = func; &#125;&#125;//事件移除function removeEvent(target, type, func) &#123; if (target.removeEventListener) &#123; target.removeEventListener(type, func, false); &#125; else if (target.detachEvent) &#123; target.detachEvent('on' + type, func); &#125; else &#123; target['on' + type] = null; &#125;&#125; 事件的传播是可以阻止的：阻止事件冒泡12345if (event.stopPropagation) &#123; event.stopPropagation();&#125; else &#123; event.cancelBubble = true; // 兼容IE&#125; 阻止事件的默认行为12345if (event.preventDefault) &#123; event.preventDefault(); &#125; else &#123; event.returnValue = false; // 兼容IE&#125; 事件代理事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。有点就是可以提高性能。1234567891011121314151617 &lt;ul id='ul'&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt; &lt;script&gt; var oUl = document.getElementById('ul'); addEvent(oUl, 'click', function(ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if (targe.nodeName.toLowerCase() === 'li') &#123; console.log(target.innerHTML); &#125; &#125;);&lt;/script&gt; JS观察者模式这是一种创建松散耦合代码的技术。它定义对象间 一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。由主体和观察者组成，主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。主体并不知道观察者的任何事情，观察者知道主体并能注册事件的回调函数。123456789101112131415161718192021222324252627282930313233343536var myEvent = (function() &#123; var handlers = &#123;&#125;; function on(evt, func) &#123; handlers[evt] = handlers[evt] || []; handlers[evt].push(func); &#125; function once(evt, func) &#123; handlers[evt] = []; handlers[evt].push(func); &#125; function off(evt, func) &#123; var handler = handlers[evt]; if (handler) &#123; for (var i = 0; i &lt; handler.length; i++) &#123; if (handler[i] === func) &#123; handler.splice(i, 1); return; &#125; &#125; &#125; &#125; function emit(evt, arg) &#123; if (handlers[evt]) &#123; for (var i = 0; i &lt; handlers[evt].length; i++) &#123; handlers[evt][i](arg); &#125; &#125; &#125; return &#123; on: on, once: once, off: off, emit: emit, &#125;; &#125;)();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"事件","slug":"事件","permalink":"http://hero-guo.com/tags/事件/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"类的继承","slug":"object-prototype","date":"2017-02-12T06:57:15.000Z","updated":"2017-08-30T14:28:05.000Z","comments":true,"path":"2017/02/12/object-prototype/","link":"","permalink":"http://hero-guo.com/2017/02/12/object-prototype/","excerpt":"混合复制 //复制source对象的属性 function mixin(source, target) { for (var key in source) { if (!(key in target)) { target[key] = source[key]; } } return target; } var Vehicle = { engines: 1, ignition: function() { console.log(&quot; Turning on my forward! &quot;); }, drive: function() { this.ignition(); console.log(&quot; Steering and moving forward! &quot;); } }; //Car复制Vehicle的属性值和函数引用 var Car = mixin(Vehicle, { wheels: 4, drive: function() { //显示指定Vehicle对象调用dirve方法 //如果直接执行Vehicle.dirve()，函数调用中的this就会绑定到Vehicle上，所以使用.call(this)来确保dirve在Car对象的上下文中执行; Vehicle.drive.call(this); console.log(&quot; Rolling on all &quot; + this.wheels + &quot;wheels!&quot;); } }); Car.drive();","text":"混合复制 //复制source对象的属性 function mixin(source, target) { for (var key in source) { if (!(key in target)) { target[key] = source[key]; } } return target; } var Vehicle = { engines: 1, ignition: function() { console.log(&quot; Turning on my forward! &quot;); }, drive: function() { this.ignition(); console.log(&quot; Steering and moving forward! &quot;); } }; //Car复制Vehicle的属性值和函数引用 var Car = mixin(Vehicle, { wheels: 4, drive: function() { //显示指定Vehicle对象调用dirve方法 //如果直接执行Vehicle.dirve()，函数调用中的this就会绑定到Vehicle上，所以使用.call(this)来确保dirve在Car对象的上下文中执行; Vehicle.drive.call(this); console.log(&quot; Rolling on all &quot; + this.wheels + &quot;wheels!&quot;); } }); Car.drive(); 寄生继承 首先复制一份父类（Vehicle），然后混入子类（Car）。然后构建实例。 //类 function Vehicle() { this.engines = 1; } Vehicle.prototype.ignition = function() { console.log(&quot; Turning on my forward! &quot;); }; Vehicle.prototype.drive = function() { this.ignition(); console.log(&quot; Steering and moving forward! &quot;); }; //寄生类Car function Car() { //car 是一个Vehicle var car = new Vehicle(); car.wheels = 4; //保存Vehicle::drive()的特殊引用 var vehDrive = car.drive; //重写Vehicle::drive() car.drive = function() { vehDrive.call(this); console.log(&quot; Rolling on all &quot; + this.wheels + &quot;wheels!&quot;); } return car; } // 因为没使用new创建的新对象而是使用返回的car，所以可以直接调用Car(); //var myCar = Car(); var myCar = new Car(); myCar.drive(); 原型继承function Foo(name) { this.name = name; } Foo.prototype.myName = function() { return this.name; } function Bar(name, label) { Foo.call(this, name); this.label = label; } //Bar.prototype 关联到 Foo.prototype //调用Object.create()创建一个新对象并把内部的[[prototype]]关联到指定的对象（Foo.prototype） //ES6直接修改现有的Bar.prototype //Object.setPrototypeOf(Bar.prototype, Foo.prototype); Bar.prototype = Object.create(Foo.prototype); Bar.prototype.constructor = Bar; Bar.prototype.myLabel = function() { return this.label; } var a = new Bar(&apos;a&apos;, &apos;obj a&apos;); Bar.prototype = Foo.prototype 并不会创建一个关联到Bar.prototype的新对象，只是直接引用Foo.prototype对象。因此执行复制语句可能会修改Foo.prototype本身。Bar.prototype = new Foo()虽然会创建一个关联到Bar.prototype的新对象，但是他使用的是new Foo()构造函数调用，如果Foo函数有一些副作用可能会影响到Bar()的后代。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"继承","slug":"继承","permalink":"http://hero-guo.com/tags/继承/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]},{"title":"充分理解闭包","slug":"closure","date":"2017-02-12T06:57:15.000Z","updated":"2017-08-30T15:35:30.000Z","comments":true,"path":"2017/02/12/closure/","link":"","permalink":"http://hero-guo.com/2017/02/12/closure/","excerpt":"闭包定义 函数定义时的作用域链到函数执行时依然有效 函数体内部到变量都可以保存在函数作用域内 闭包可以访问它被创建时候到上下文环境","text":"闭包定义 函数定义时的作用域链到函数执行时依然有效 函数体内部到变量都可以保存在函数作用域内 闭包可以访问它被创建时候到上下文环境 作用域由于闭包是基于词法作用域书写代码时所产生到自然结果，所以为了理解闭包，我们先来看看什么是词法作用域。 什么是词法作用域？大部分标准语言编译器到第一个工作阶段叫做词法化。简单的说词法作用域就是定义在词法阶段到作用域（也就是说函数声明的位置）。 12345678910function foo(a) &#123; var b = a * 2; function bar(c) &#123; console.log(a, b, c); &#125; bar(b * 3);&#125;foo(2); //=&gt; 2, 4, 12 在上面到代码中有3个逐级嵌套到作用域。 包含着整个全局作用域，其中只有一个标识符： foo； 包含foo所创建到作用域，其中有三个标识符：a、bar、b； 包含bar所创建到作用域，其中有一个标识符：c。 在引擎执行console.log(…)声明，并查找a、b、c三个变量到引用时。首先从最内部到作用域也就是bar()函数作用域开始查找。引擎无法找到a就会继续向上查找也就是foo()函数作用域。在这里找到来a。对于b来讲也是一样的。作用域查找会在找到第一个匹配的标识符时停止。 闭包的产生当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前的词法作用域之外执行。123456789function foo() &#123; var a = 2; function bar() &#123; console.log(a); &#125; return bar;&#125;var baz = foo();baz(); // =&gt; 2 这就是闭包 函数bar的词法作用域能够访问foo的内部作用域。然后我们返回bar本身。当foo执行后，其返回值（也就是bar函数）赋值给变量baz并调用baz，实际上只是通过不同的标识符引用了内部的函数bar。虽然bar是在定义的词法作用域以外被调用，但是闭包可以访问它被创建时候到上下文环境，所以还是可以访问到变量a。这是为什么呢？ 在foo执行之后。通常foo到整个内部作用域都会被销毁，因为引擎有垃圾回收机制用来释放不在使用到内存空间。但是因为bar声明在foo的内部，它拥有涵盖foo内部作用域的闭包，是的该作用域一直存在，并被bar随时引用。 无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。 12345678910function foo() &#123; var a = 2; function baz() &#123; console.log(a); &#125; bar(baz);&#125;function bar(fn) &#123; fn(); //闭包&#125; 随处可见到闭包你已经写过到代码中一定到处都是闭包到影子。123456function wait(message) &#123; setTimeout(function timer() &#123; console.log(message); &#125;, 1000)&#125;wait('Hello, closure'); wait执行1000毫秒后，它到内部作用域并不会消失，timer函数依然可以访问它内部到变量message。123456function setupBot(name, selector) &#123; $(selector).click(function activator() &#123; console.log('Activating:' + name); &#125;);&#125;setupBot('Closure Bot 1', '#bot1'); 本质上无论何时何地。如果将函数当作第一级到值类型并到处传递，你就会看到闭包了。 循环和闭包12345for (var i=1; i&lt;=5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i*1000)&#125; 这段代码期望是输出1～5，每秒一次，每次一个。但是实际上是每秒一次输出到都是6。这是为什么呢？ 原来循环中定义的函数都共享一个全局作用域，因此实际上只有一个i。因此我们需要更多的闭包作用域，特别是循环过程中每个迭代都需要一个闭包作用域。1234567for(var i=1; i&lt;=5; i++) &#123; (function(j) &#123; setTimeout(function() &#123; console.log(j) &#125;, j*1000) &#125;)(i);&#125; 使用let可以有更简单都写法12345for(let i=1; i&lt;=5; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, i*1000)&#125; 这是因为let每次迭代都会重新声明一个作用域。 参考《你不知道的javascript上》 《javascript权威指南》 《javascript高级程序设计》 《javascript语言精粹》","categories":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"闭包","slug":"闭包","permalink":"http://hero-guo.com/tags/闭包/"}],"keywords":[{"name":"Notes","slug":"Notes","permalink":"http://hero-guo.com/categories/Notes/"}]},{"title":"ES6-MIXIN","slug":"ES6-mixin","date":"2016-12-11T06:57:15.000Z","updated":"2018-07-11T15:34:09.631Z","comments":true,"path":"2016/12/11/ES6-mixin/","link":"","permalink":"http://hero-guo.com/2016/12/11/ES6-mixin/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 //通过class实现混入//extends 可以继承动态构造的类const Mixin = Sup =&gt; class extends Sup &#123; //构造方法 //this关键字则代表实例对象 constructor(...args) &#123; //（1）作为函数调用时（即super(...args)），super代表父类的构造函数。 //（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。 super(...args); &#125;&#125;class Widget &#123; constructor(width, height, $elem) &#123; Object.assign(this, &#123; width, height, $elem: null &#125;); &#125; render($where) &#123; if (this.$elem) &#123; this.$elem.css(&#123; width: this.width + 'px', height: this.height + 'px' &#125;).appendTo($where); &#125; &#125;&#125;class Button extends Mixin(Widget) &#123; constructor(width, height, label)&#123; super(width, height); this.label = label; this.$elem = $('&lt;button&gt;').text(this.label); &#125; render($where) &#123; super.render($where); this.$elem.click(this.onClick); &#125; onClick() &#123; console.log('Button' + this.label + 'clicked!'); &#125;&#125;const $body = $(document.body) || document.body;let btn = new Button(125, 30, 'hello world');btn.render($body);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://hero-guo.com/tags/ES6/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://hero-guo.com/categories/JavaScript/"}]}]}