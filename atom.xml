<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Neil&#39;s site</title>
  <icon>https://www.gravatar.com/avatar/124e8e573a49899e984bcaeb9daf2b5e</icon>
  <subtitle>A bird is known by its note, and a man by his talk.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://hero-guo.com/"/>
  <updated>2019-01-06T07:42:28.517Z</updated>
  <id>http://hero-guo.com/</id>
  
  <author>
    <name>Neil Guo</name>
    <email>handsamechina@126.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git 使用</title>
    <link href="http://hero-guo.com/2019/01/06/git/"/>
    <id>http://hero-guo.com/2019/01/06/git/</id>
    <published>2019-01-06T06:02:41.000Z</published>
    <updated>2019-01-06T07:42:28.517Z</updated>
    
    <content type="html"><![CDATA[<h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p> 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><ol><li><strong>集中化的版本控制系统（SVN）</strong><br>有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。<br><img src="/2019/01/06/git/svn.png" alt=""><br>但是这么做有一个缺点是中央服务器的单点故障，如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据。</li><li><strong>分布式版本控制系统（GIT）</strong><br>客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。<br><img src="/2019/01/06/git/git.png" alt=""><a id="more"></a></li></ol><h4 id="Git"><a href="#Git" class="headerlink" title="Git "></a><a href="https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-Git-%E7%AE%80%E5%8F%B2" target="_blank" rel="noopener">Git </a></h4><p>自诞生于 2005 年以来，Git 日臻成熟完善，在高度易用的同时，仍然保留着初期设定的目标。 它的速度飞快，极其适合管理大项目，有着令人难以置信的非线性分支管理系统。<a href="http://www.aqee.net/post/5-fundamental-differences-between-git-svn.html" target="_blank" rel="noopener"><strong>Git 与 Svn 的区别</strong></a></p><p><strong>优点</strong></p><ul><li>免费的、开源的、分布式的版本控制系统</li><li>版本库本地化，支持离线提交，相对独立不影响协同开发</li><li><strong>更少的“仓库污染”。</strong>git对于每个工程只会产生一个.git目录，这个工程所有的版本控制信息都在这个目录中，不会像SVN那样在每个目录下都产生.svn目录。</li><li><strong>把内容按元数据方式存储，完整克隆版本库。</strong>所有版本信息位于.git目录中，它是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签、分支、版本记录等。</li><li><strong>支持快速切换分支方便合并，比较合并性能好。</strong>在同一目录下即可切换不同的分支，方便合并，且合并文件速度比SVN快。</li><li><strong>分布式版本库，无单点故障，内容完整性好。</strong>内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ul><h4 id="Git-基本工作原理"><a href="#Git-基本工作原理" class="headerlink" title="Git 基本工作原理"></a>Git 基本工作原理</h4><ul><li><strong>直接记录快照，而非差异比较</strong></li></ul><p>Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。 概念上来区分，其它大部分系统以文件变更列表的方式存储信息。 这类系统（CVS、Subversion、Perforce、Bazaar 等等）将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</p><p><img src="/2019/01/06/git/svn-check.png" alt=""></p><p>Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。相当于每一个分支就是一个小型的文件管理系统。</p><p><img src="/2019/01/06/git/git-check.png" alt=""></p><ul><li><strong>近乎所有操作都是本地执行</strong></li></ul><p>在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 如你在飞机或火车上想做些工作，你能愉快地提交，直到有网络连接时再上传。 </p><ul><li><strong>Git 保证完整性</strong></li></ul><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样：<code>24b9da6552252987aa493b52f8696cd6d3b00373</code></p><ul><li><strong>Git 一般只添加数据</strong></li></ul><p>你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 </p><ul><li><strong>Git 三种状态</strong></li></ul><p><strong>已提交（committed）</strong>、<strong>已修改（modified）</strong>、<strong>已暂存（staged）</strong></p><p>基本的 Git 工作流程如下：</p><ol><li>在工作目录中修改文件。</li><li>暂存文件，将文件的快照放入暂存区域。</li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</li></ol><h4 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h4><p><img src="/2019/01/06/git/git-repo.png" alt=""></p><ol><li><p><code>git clone</code> 将存储库克隆到新创建的目录中，为克隆存储库中的每个分支创建远程跟踪分支并检出从克隆存储库的当前活动分支分叉的初始分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:zeit/next.js.git [dir-name]</span><br><span class="line"><span class="meta">#</span> dir-name 是可选的 没有的话默认创建与远程库名称相同的文件夹</span><br></pre></td></tr></table></figure></li><li><p><code>git checkout &lt;branch&gt;</code>  切换分支或恢复工作树文件，如果本地没有该分支会去远程拉去</p></li><li><p><code>git branch</code> 列出，创建或删除分支</p></li><li><p><code>git add .</code> 将文件内容添加到索引中</p></li><li><p><code>git commit -am &#39;xxx&#39;</code> 记录对存储库的更改</p></li><li><p><code>git pull</code> 从另一个存储库或本地分支获取并与其集成 相当于 <code>git fetch</code>  + <code>git merge</code></p></li><li><p><code>git push</code> 使用本地引用更新远程引用，同时发送完成给定引用所必需的对象。</p></li><li><p><code>git checkout . &amp;&amp; git clean -xdf</code> 删除本地变更文件</p></li><li><p><code>git status</code> 显示工作树状态</p></li><li><p><code>git merge</code> 将两个或多个开发历史记录连接在一起</p></li><li><p><code>git rebase</code> 重新应用提交在另一个基本提示之上，在未将变更推送到远程之前可以整理 commit 提交信息。<a href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing" target="_blank" rel="noopener">rebase vs merge</a> <a href="https://www.jianshu.com/p/f23f72251abc" target="_blank" rel="noopener">rebase vs merge(中文)</a></p><p><img src="/2019/01/06/git/rebase-merge.png" alt=""></p></li></ol><h4 id="分支管理工具-Git-Flow"><a href="#分支管理工具-Git-Flow" class="headerlink" title="分支管理工具 Git-Flow"></a>分支管理工具 <a href="http://danielkummer.github.io/git-flow-cheatsheet/index.zh_CN.html" target="_blank" rel="noopener">Git-Flow</a></h4><p><img src="/2019/01/06/git/git-flow-nvie.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h4&gt;&lt;p&gt; 版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;集中化的版本控制系统（SVN）&lt;/strong&gt;&lt;br&gt;有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。&lt;br&gt;&lt;img src=&quot;/2019/01/06/git/svn.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;但是这么做有一个缺点是中央服务器的单点故障，如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;分布式版本控制系统（GIT）&lt;/strong&gt;&lt;br&gt;客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。 这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。&lt;br&gt;&lt;img src=&quot;/2019/01/06/git/git.png&quot; alt=&quot;&quot;&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://hero-guo.com/categories/Notes/"/>
    
    
      <category term="Git" scheme="http://hero-guo.com/tags/Git/"/>
    
      <category term="Git-Flow" scheme="http://hero-guo.com/tags/Git-Flow/"/>
    
  </entry>
  
  <entry>
    <title>在 React 项目中使用 Redux 和 Redux-Saga</title>
    <link href="http://hero-guo.com/2018/12/02/%E5%9C%A8-React-%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8-Redux-%E5%92%8C-Redux-Saga/"/>
    <id>http://hero-guo.com/2018/12/02/在-React-项目中使用-Redux-和-Redux-Saga/</id>
    <published>2018-12-02T13:52:32.000Z</published>
    <updated>2018-12-02T13:56:17.239Z</updated>
    
    <content type="html"><![CDATA[<p>关于 React 的数据管理库现在社区有很多解决方案，<a href="https://mobx.js.org/" target="_blank" rel="noopener">Mobx</a>，<a href="https://redux.js.org/" target="_blank" rel="noopener">Redux</a>，<a href="https://rxjs-dev.firebaseapp.com/" target="_blank" rel="noopener">RxJs</a>等。关于他们的优劣与适合的场景网上有很多讨论。本文主要介绍 Redux 与 Redux MiddleWare 。<br><a id="more"></a></p><h5 id="何时需要使用-Redux"><a href="#何时需要使用-Redux" class="headerlink" title="何时需要使用 Redux"></a>何时需要使用 Redux</h5><ol><li>多层级组件之间需要共享数据</li><li>应用状态嵌套层级很深</li><li>期望使用单一数据流</li></ol><h5 id="Redux-核心概念"><a href="#Redux-核心概念" class="headerlink" title="Redux 核心概念"></a>Redux 核心概念</h5><p>使用普通对象描述应用程序的状态，强制将状态的更改描述为一个操作，每次操作由一个动作 <code>action</code> 触发。通过 <code>reducer</code> 函数将动作和状态联系起来。</p><p>Redux的实现有三大基本原则：</p><ol><li>单一数据源</li><li>State 是只读的</li><li>使用纯函数来执行修改</li></ol><h4 id="Redux-使用"><a href="#Redux-使用" class="headerlink" title="Redux 使用"></a>Redux 使用</h4><p>Redux 的源码很少，使用起来也很简单，比较难理解的是它的中间件思想。</p><p>1.安装</p>   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux react-redux redux-saga</span><br></pre></td></tr></table></figure><p>2.使用 <code>create-react-app</code> 创建项目之后，创建 store 文件夹</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// store 文件夹</span><br><span class="line">├── index.js</span><br><span class="line">├── middleware</span><br><span class="line">│   ├── index.js</span><br><span class="line">├── reducers</span><br><span class="line">│   ├── index.js</span><br><span class="line">└── sagas</span><br><span class="line">    ├── index.js</span><br></pre></td></tr></table></figure><p>3.创建 store</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//store/index.js</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @导出全局 store 基于 redux-sage</span></span><br><span class="line"><span class="comment"> * @format</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// redux-devtools-extension 可以在浏览器里面查看 store 的状态</span></span><br><span class="line"><span class="keyword">import</span> &#123; applyMiddleware, createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; composeWithDevTools &#125; <span class="keyword">from</span> <span class="string">'redux-devtools-extension/logOnlyInProduction'</span></span><br><span class="line"><span class="keyword">import</span> &#123; localStore &#125; <span class="keyword">from</span> <span class="string">'helpers'</span> <span class="comment">// localStorage 的封装</span></span><br><span class="line"><span class="keyword">import</span> &#123; sageMiddleware &#125; <span class="keyword">from</span> <span class="string">'./middleware'</span></span><br><span class="line"><span class="keyword">import</span> rootSaga <span class="keyword">from</span> <span class="string">'./sagas'</span></span><br><span class="line"><span class="keyword">import</span> rootReducer <span class="keyword">from</span> <span class="string">'./reducers'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> middlewares = [sageMiddleware]</span><br><span class="line"><span class="keyword">const</span> composeEnhancers = composeWithDevTools(&#123;</span><br><span class="line">  <span class="comment">// redux-devtools-extension 的一些配置。一般情况不需要配置</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 如果需要从本地获取数据同步到 store 里面</span></span><br><span class="line"><span class="keyword">const</span> xxx = localStore.get(<span class="string">'xxx'</span>) || &#123;&#125; <span class="comment">// 获取本地数据</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  rootReducer, <span class="comment">// redux 数据处理函数</span></span><br><span class="line">  xxx, <span class="comment">// 初始化数据，可以不填</span></span><br><span class="line">  composeEnhancers( <span class="comment">// redux 中间件 增强 redux 的数据处理能力</span></span><br><span class="line">    applyMiddleware(...middlewares)</span><br><span class="line">  )</span><br><span class="line">)</span><br><span class="line">store.runSage = sageMiddleware.run</span><br><span class="line">store.runSage(rootSaga) <span class="comment">// 动态地运行 saga</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleChange</span>(<span class="params"></span>) </span>&#123; <span class="comment">// redux 被触发的监听函数</span></span><br><span class="line">  <span class="comment">// 存储 store 数据到本地缓存</span></span><br><span class="line">  <span class="keyword">const</span> state = store.getState() <span class="comment">// 获取当前 store 里面的全部数据</span></span><br><span class="line">  localStore.set(<span class="string">'xxx'</span>, state) <span class="comment">// 存储到 localStorage</span></span><br><span class="line">&#125;</span><br><span class="line">store.subscribe(handleChange)</span><br><span class="line"><span class="comment">// Enable Webpack hot module replacement for reducers</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123; <span class="comment">// webpack 热更新时候同步 redux</span></span><br><span class="line">  <span class="built_in">module</span>.hot.accept(<span class="string">'./reducers'</span>, () =&gt; &#123;</span><br><span class="line">    store.replaceReducer(<span class="built_in">require</span>(<span class="string">'./reducers/index'</span>).default)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><p>4.创建 reducer</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/reducers/index.js</span></span><br><span class="line"><span class="comment">// combineReducers 是一个高阶函数。主要作用是合并多个 reducer</span></span><br><span class="line"><span class="keyword">import</span> &#123; combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">'./todo'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123; todo &#125;)</span><br></pre></td></tr></table></figure>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/reducers/todo.js</span></span><br><span class="line"><span class="comment">// 定义 action</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO_PENDDING = <span class="string">'todo/ADD_TODO_PENDDING'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO_SUCCEEDED = <span class="string">'todo/ADD_TODO_SUCCEEDED'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD_TODO_FAILURED = <span class="string">'todo/ADD_TODO_FAILURED'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="comment">// 传入初始化 state</span></span><br><span class="line">  todos: [],</span><br><span class="line">  loading: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据 action.type 处理 state，不能修改 state，可以使用 Object.assing() 或者 展开运算符 &#123;...state&#125; 生成一个副本</span></span><br><span class="line"><span class="comment">// 只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state = initialState, action = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; payload &#125; = action</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO_PENDDING:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state &#125;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO_SUCCEEDED:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">todos</span>: payload, <span class="attr">loading</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">case</span> ADD_TODO_FAILURE:</span><br><span class="line">      <span class="keyword">return</span> &#123; ...state, <span class="attr">loading</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.创建 sagas</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/sagas/index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; all, fork &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">'./todo'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">root</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> all([fork(todo)])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store/sagas/todo.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../reducers/todo'</span></span><br><span class="line"><span class="keyword">import</span> &#123; $request &#125; <span class="keyword">from</span> <span class="string">'helpers'</span> <span class="comment">// 基于 axios 封装的请求方法</span></span><br><span class="line"><span class="keyword">import</span> &#123; call, put &#125; <span class="keyword">from</span> <span class="string">'redux-saga/effects'</span></span><br><span class="line"><span class="keyword">import</span> &#123; takeLatest &#125; <span class="keyword">from</span> <span class="string">'redux-saga'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">addTodo</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = <span class="keyword">yield</span> call(<span class="function"><span class="params">()</span> =&gt;</span> $request.post(<span class="string">'/addTodo'</span>, action))</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: actionTypes.ADD_TODO_SUCCEEDED, <span class="attr">payload</span>: data &#125;)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">yield</span> put(&#123; <span class="attr">type</span>: actionTypes.ADD_TODO_FAILURED&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>* <span class="title">saga</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* takeLatest(actionTypes.ADD_TODO_PENDDING, addTodo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.连接 React 和 Redux</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/routes</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span></span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span></span><br><span class="line"><span class="keyword">import</span> &#123; NoMatch, Loading &#125; <span class="keyword">from</span> <span class="string">'components'</span></span><br><span class="line"><span class="keyword">const</span> AddTodo = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./container/AddTodo'</span>),</span><br><span class="line">  loading: Loading</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">Routes</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;store&#125;&gt; <span class="comment">// 传递 store</span></span><br><span class="line">      &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125; /&gt;</span><br><span class="line">          &lt;Route path=<span class="string">"/add"</span> component=&#123;AddTodo&#125; /&gt;</span><br><span class="line">          &lt;Route component=&#123;NoMatch&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>BrowserRouter&gt;</span><br><span class="line">    &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/index.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'./style/antd.less'</span></span><br><span class="line"><span class="keyword">import</span> Routes <span class="keyword">from</span> <span class="string">'./routes'</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Routes</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><p>7.触发 action</p>   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// container/AddTodo.js</span></span><br><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actionTypes <span class="keyword">from</span> <span class="string">'../store/reducers/todo'</span></span><br><span class="line">@connect(&#123; state =&gt; &#123; <span class="attr">data</span>: state.todo &#125; &#125;)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddTodo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    handleAdd = <span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 触发 redux 的 action</span></span><br><span class="line">        <span class="keyword">this</span>.props.dispatch(&#123;<span class="attr">type</span>: actionTypes.ADD_TODO_PENDDING, data &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 省略布局实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Redux-的中间件"><a href="#Redux-的中间件" class="headerlink" title="Redux 的中间件"></a>Redux 的中间件</h4><p>Redux 里的 <code>createStore(reducer, [preloadedState], enhancer)</code> 第三个参数就是传入的中间件，第二个参数是可选的，如果不传，第二个参数就是中间件。主要的作用是提供 action 被发起之后，到达 reducer 之前的扩展点。可以记录每次 action 被触发的日志<code>redux-logger</code>，可以添加浏览器扩展<code>redux-devtools-extension</code> 。我们经常是用的功能是增强 action 的能力，因为 action 被定义为一个对象，原始情况下只能处理同步操作。通过添加中间件，我们可以传递一个发送网络请求的 action。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// redux thunk</span></span><br><span class="line"><span class="keyword">const</span> thunk = <span class="function"><span class="params">store</span> =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span></span><br><span class="line">  <span class="keyword">typeof</span> action === <span class="string">'function'</span> ?</span><br><span class="line">    action(store.dispatch, store.getState) :</span><br><span class="line">    next(action)</span><br></pre></td></tr></table></figure><h4 id="Redux-Saga"><a href="#Redux-Saga" class="headerlink" title="Redux-Saga"></a>Redux-Saga</h4><p>Redux 的增强 action 使其具有网络请求能力的中间件有很多种 <code>redux-thunk</code> <code>redux-promise</code> <code>redux-saga</code> <code>redux-observable</code> 等。各有优劣，这里主要讲一下比较流行的 <code>redux-saga</code>。</p><p><code>redux-saga</code>是一个旨在处理应用程序的副作用（网络请求，用户事件，浏览器缓存等），使其更容易管理，更容易测试的库。上面的代码里面已经展现了它的基本使用方法，这里我们主要讲一下它的基本原理。</p><p><code>redux-saga</code> 是基于 ES6的新特性 <code>Generators</code> 实现的。它内部实现了很多辅助函数，这些辅助函数用于处理 action。 对于一个网络请求我们默认会有三种状态，类似于 Promise，<code>PENDDING</code>，<code>FULFILLED</code>，<code>REJECTED</code>。也就是说一次完整的请求我们需要设置三种类型的 action。</p><p>常用的一些辅助方法有</p><ul><li><code>call(fn, ...args)</code> 发送一个请求，第一个参数是一个函数，期望返回一个 <code>promise</code>，同步调用，等待调用的返回</li><li><code>fork(fn, ...args)</code> 同 <code>call</code> 使用方法相似，只是它<strong>非阻塞调用</strong> 的形式执行 <code>fn</code></li><li><code>put(action)</code> 类是与 redux 的 dispatch 函数，主要作用是触发一个 action</li><li><code>take(pattern)</code> 是最基本的一个方法，很多高级的方法都是基于他实现的。主要作用是在action 触发之前 <code>Generators</code> 函数是暂停的。</li><li><code>select(selector, ...args)</code> 选择当前 store 里面的 state</li><li><code>takeEvery(pattern, saga, ...args)</code>  <code>take</code> 的高级应用，监听 action 的触发，每次触发都会执行一次<code>pattern</code></li><li><code>takeLatest(pattern, saga, ...args)</code> 与 <code>takeEvery</code>相似， 每次触发都会执行 <code>pattern</code>，但是他会取消上一次执行中的 <code>saga</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于 React 的数据管理库现在社区有很多解决方案，&lt;a href=&quot;https://mobx.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mobx&lt;/a&gt;，&lt;a href=&quot;https://redux.js.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redux&lt;/a&gt;，&lt;a href=&quot;https://rxjs-dev.firebaseapp.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RxJs&lt;/a&gt;等。关于他们的优劣与适合的场景网上有很多讨论。本文主要介绍 Redux 与 Redux MiddleWare 。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="React" scheme="http://hero-guo.com/tags/React/"/>
    
      <category term="Redux" scheme="http://hero-guo.com/tags/Redux/"/>
    
      <category term="Redux-Saga" scheme="http://hero-guo.com/tags/Redux-Saga/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件循环探索</title>
    <link href="http://hero-guo.com/2018/07/11/javascript%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%8E%A2%E7%B4%A2/"/>
    <id>http://hero-guo.com/2018/07/11/javascript事件循环探索/</id>
    <published>2018-07-11T13:28:57.000Z</published>
    <updated>2018-07-11T15:28:06.687Z</updated>
    
    <content type="html"><![CDATA[<p>一直对js的事件循环不是很清晰，最近看了JavaScript忍者秘籍的第13章后，有了一些感悟，特此总结一下，分享给大家。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>众所周知，JavaScript是单线程执行模型，同一时刻只能执行一个代码片段，一个任务开始后知道运行完成，不会被其他任务中断。当一个任务花费的时间很长的话，用户就会明显的感觉到卡顿。浏览器为了解决这个问题引入了事件循环的概念（Event Loop）。</p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>事件循环具有至少两个队列处理任务。任务分为两类，宏任务（macro-task）和微任务（micro-task）。</p><ol><li>宏任务代表一个个离散、独立的工作单元，运行完之后，浏览器可以继续其他的调度。包括：创建文档对象，解析HTML，执行JavaScript，以及各种事件……</li><li>微任务是更小的任务，主要用户更新应用程序的状态，必须在浏览器任务继续执行其他任务之前执行。微任务需要尽可能快地通过异步方式执行，同时不能产生全新的微任务。包括promise、回调函数、DOM发生变化……</li></ol><h4 id="仅包含宏任务"><a href="#仅包含宏任务" class="headerlink" title="仅包含宏任务"></a>仅包含宏任务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程JavaScript运行15ms</span></span><br><span class="line">btn1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;运行 <span class="number">8</span>ms&#125;, <span class="literal">false</span>);</span><br><span class="line">btn2.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;运行 <span class="number">5</span>ms&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>​    现在假设主线程运行15ms， 在第5ms单击btn1，在第12ms的时候单击btn2。基于单线程执行模型，单击按钮之后不会立即执行对应的处理函数，因为一个任务一旦开始就不会被另一个任务中断。因此，在主线程执行的15ms期间，按钮的单击处理函数放入队列。当主线程执行完成也就是15ms之后，程序开始处理微任务，因为当前不存在微任务，跳过此步骤，开始执行更新UI。</p><p>​    之后进入第二次循环，也就是开始执行btn1的处理函数，需要运行8ms，btn2处理函数在队列中等待。当btn1处理函数执行完之后，浏览器检查微任务是否存在和是否更新UI，删除任务队列里的btn1的处理函数。</p><p>​    最后进入第三次循环，开始执行btn2的处理函数，需要运行5ms，处理函数执行完之后，检查微任务和是否需要更新UI，删除任务队列里的btn2的处理函数，最终任务队列为空，循环结束。</p><h4 id="同时含有宏任务和微任务"><a href="#同时含有宏任务和微任务" class="headerlink" title="同时含有宏任务和微任务"></a>同时含有宏任务和微任务</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程JavaScript运行15ms</span></span><br><span class="line">btn1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       运行 <span class="number">4</span>ms </span><br><span class="line">    &#125;);</span><br><span class="line">    运行 <span class="number">8</span>ms </span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">btn2.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;运行 <span class="number">5</span>ms&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>本例中在btn1的事件处理函数里增加了一个立即兑现的Promise，需要运行4ms。</p><p>现在代码的执行顺序为：</p><pre><code>1. 主线程执行15ms，在5ms和12ms的时候分别将处理函数放入任务队列，更新UI。2. 15m后处理btn1事件处理函数，发现Promise，放入微任务队列，btn1事件处理函数继续执行8ms，检查微任务队列发现有Promise回调函数，然后开始执行Promise回调函数，运行4ms，继续检查微任务队列，如果为空，检查是否需要更新UI，进入下一轮循环。3. 处理btn2的事件处理函数……</code></pre><h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><p>基于上面的事件循环机制，现在我们来看一种特殊类型的事件：<em>计时器</em>。浏览器提供了两种创建计时器的方法 <code>setTimeout</code> 和 <code>setInterval</code>。 他们都挂载在 <code>window</code> 对象上。</p><p> <code>setTimeout</code>：在指定的延迟时间结束时执行一次回调函数，返回标识计时器的唯一值，可用于取消定时器（<code>clearTimeout(id)</code>）。</p><p><code>setInterval</code>：按照指定的延迟间隔不断的执行回调函数，返回标识计时器的唯一值，可用于取消定时器（<code>clearInterval(id)</code>）。</p><h4 id="事件循环中的定时器"><a href="#事件循环中的定时器" class="headerlink" title="事件循环中的定时器"></a>事件循环中的定时器</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主线程JavaScript运行18ms</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    运行<span class="number">6</span>ms;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    运行<span class="number">8</span>ms;</span><br><span class="line">&#125;, <span class="number">10</span>);</span><br><span class="line">btn1.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;运行 <span class="number">10</span>ms&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>👆代码的执行过程是什么呢？</p><p>现在我们想象一下主线程代码需要运行18ms，在第6ms的时候用户点击了按钮，在第10ms延迟计时器到期，间隔计时器第一次触发。</p><p>我们知道一个任务一旦开始执行，就无法被其他任务中断。所以，6ms将事件处理函数加入队列，10ms分别将延迟计时器和间隔计时器回调放入队列。运行到18m主线程执行完毕，检查微任务队列和更新UI，进入下一个时间循环。开始执行btn1事件回调，运行10ms，这时候在btn1事件回调运行的过程中，<em>间隔计时器第二次到期，但是任务队列里面已经有一个间隔计时器处理函数</em>，所以忽略这个处理函数。btn1事件回调运行结束，检查微任务队列和更新UI，进入下一个事件循环。开始执行延迟计时器处理函数，运行6ms，在这个过程中间隔计时器第三次到期，但是由于任务队列已经有了处理函数，继续忽略。延迟计时器处理函数运行完毕，检查微任务队列和更新UI，进入下一个事件循环。现在开始执行间隔计时器处理函数，运行8ms，在这期间间隔计时器第四次到期，这时候任务队列里没有处理函数，所以将这次的处理函数放入任务队列，间隔定时器处理函数运行完成，检查微任务队列和更新UI，进入下一个事件循环，然后重复运行间隔定时器……</p><p>通过以上的执行过程我们发现，<strong>我们只能控制计时器何时被加入队列，而无法控制何时执行。</strong></p><p>最后，JavaScript的事件循环是这门语言非常重要的基础，由于我水平有限以上只是简单总结了一下它的执行过程。大家可以深入研究一下<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" target="_blank" rel="noopener">Nodejs的事件循环</a></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直对js的事件循环不是很清晰，最近看了JavaScript忍者秘籍的第13章后，有了一些感悟，特此总结一下，分享给大家。&lt;/p&gt;
&lt;h3 id=&quot;单线程&quot;&gt;&lt;a href=&quot;#单线程&quot; class=&quot;headerlink&quot; title=&quot;单线程&quot;&gt;&lt;/a&gt;单线程&lt;/h3&gt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="事件循环" scheme="http://hero-guo.com/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>扩展原生Number</title>
    <link href="http://hero-guo.com/2018/02/05/%E6%89%A9%E5%B1%95%E5%8E%9F%E7%94%9FNumber/"/>
    <id>http://hero-guo.com/2018/02/05/扩展原生Number/</id>
    <published>2018-02-05T14:46:27.000Z</published>
    <updated>2018-02-05T14:52:50.457Z</updated>
    
    <content type="html"><![CDATA[<p>今天看<a href="https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20%26%20beyond/ch3.md" target="_blank" rel="noopener"><strong>你不知道的js</strong></a> 第三章有个比较有意思的方法，特记录一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Number</span>.prototype[<span class="built_in">Symbol</span>.iterator]) &#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(</span><br><span class="line"><span class="built_in">Number</span>.prototype,</span><br><span class="line"><span class="built_in">Symbol</span>.iterator,</span><br><span class="line">&#123;</span><br><span class="line">writable: <span class="literal">true</span>,</span><br><span class="line">configurable: <span class="literal">true</span>,</span><br><span class="line">enumerable: <span class="literal">false</span>,</span><br><span class="line">value: <span class="function"><span class="keyword">function</span> <span class="title">iterator</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> i, inc, done = <span class="literal">false</span>, top = +<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iterate positively or negatively?</span></span><br><span class="line">inc = <span class="number">1</span> * (top &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="comment">// make the iterator itself an iterable!</span></span><br><span class="line">[<span class="built_in">Symbol</span>.iterator]()&#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;,</span><br><span class="line"></span><br><span class="line">next() &#123;</span><br><span class="line"><span class="keyword">if</span> (!done) &#123;</span><br><span class="line"><span class="comment">// initial iteration always 0</span></span><br><span class="line"><span class="keyword">if</span> (i == <span class="literal">null</span>) &#123;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iterating positively</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">i = <span class="built_in">Math</span>.min(top,i + inc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iterating negatively</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">i = <span class="built_in">Math</span>.max(top,i + inc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// done after this iteration?</span></span><br><span class="line"><span class="keyword">if</span> (i == top) done = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">value</span>: i, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> <span class="number">3</span>) &#123;</span><br><span class="line"><span class="built_in">console</span>.log( i );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 1 2 3</span></span><br><span class="line"></span><br><span class="line">[...<span class="number">-3</span>];<span class="comment">// [0,-1,-2,-3]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天看&lt;a href=&quot;https://github.com/getify/You-Dont-Know-JS/blob/master/es6%20%26%20beyond/ch3.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;strong&gt;你不知道
      
    
    </summary>
    
      <category term="Notes" scheme="http://hero-guo.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://hero-guo.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>使用commitlint规范git提交</title>
    <link href="http://hero-guo.com/2018/02/05/%E4%BD%BF%E7%94%A8commitlint%E8%A7%84%E8%8C%83git%E6%8F%90%E4%BA%A4/"/>
    <id>http://hero-guo.com/2018/02/05/使用commitlint规范git提交/</id>
    <published>2018-02-05T14:06:11.000Z</published>
    <updated>2018-02-05T14:13:28.413Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://marionebl.github.io/commitlint/" target="_blank" rel="noopener">commitlint</a>: git 提交信息规范与验证</p><p><a href="https://github.com/typicode/husky/tree/master" target="_blank" rel="noopener">husky</a>: 使ghook更容易</p><p><a href="https://github.com/conventional-changelog/standard-version" target="_blank" rel="noopener">standard-version</a>: 自动生成CHANGELOG 并发布版本</p><p>安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @commitlint/&#123;config-conventional,cli&#125;</span><br><span class="line">npm i --save-dev standard-version</span><br><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><ol><li>commitlint</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;module.exports = &#123;extends: [&apos;@commitlint/config-conventional&apos;]&#125;&quot; &gt; commitlint.config.js</span><br><span class="line">// commitlint.config.js</span><br><span class="line"> module.exports = &#123;</span><br><span class="line">  extends: [&apos;@commitlint/config-conventional&apos;],</span><br><span class="line">  rules: &#123;</span><br><span class="line">  &apos;type-enum&apos;: [2, &apos;always&apos;, [</span><br><span class="line">     &quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;perf&quot;, &quot;test&quot;, &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;revert&quot;</span><br><span class="line">   ]],</span><br><span class="line">  &apos;scope-empty&apos;: [2, &apos;never&apos;],</span><br><span class="line">  &apos;subject-full-stop&apos;: [0, &apos;never&apos;], </span><br><span class="line">  &apos;subject-case&apos;: [0, &apos;never&apos;]</span><br><span class="line">  &#125;&#125;;</span><br></pre></td></tr></table></figure><ol><li>tandard-version 和 husky</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// package.json</span><br><span class="line"> &quot;scripts&quot;: &#123;</span><br><span class="line">  &quot;lint&quot;: &quot;eslint .&quot;,</span><br><span class="line">  &quot;commitmsg&quot;: &quot;commitlint -e $GIT_PARAMS&quot;,</span><br><span class="line">  &quot;release&quot;: &quot;standard-version&quot;,</span><br><span class="line">  &quot;validate&quot;: &quot;npm prune&quot;,</span><br><span class="line">  &quot;pre-commit&quot;: &quot;npm run lint&quot;,</span><br><span class="line">  &quot;pre-push&quot;: &quot;npm run validate&quot;,</span><br><span class="line">  &quot;npmi&quot;: &quot;npm i&quot;,</span><br><span class="line">  &quot;post-merge&quot;: &quot;npm run npmi&quot;,</span><br><span class="line">  &quot;post-rewrite&quot;: &quot;npm run npmi&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://marionebl.github.io/commitlint/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;commitlint&lt;/a&gt;: git 提交信息规范与验证&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://git
      
    
    </summary>
    
      <category term="Notes" scheme="http://hero-guo.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="git" scheme="http://hero-guo.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>前端发展史</title>
    <link href="http://hero-guo.com/2017/12/17/%E5%89%8D%E7%AB%AF%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
    <id>http://hero-guo.com/2017/12/17/前端发展史/</id>
    <published>2017-12-17T07:04:20.000Z</published>
    <updated>2017-12-17T06:38:50.667Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是前端"><a href="#什么是前端" class="headerlink" title="什么是前端"></a>什么是前端</h5><p>前端工程师主要利用HMTL与CSS构建页面，用JavaScript完善交互以及用户体验。</p><h4 id="诞生"><a href="#诞生" class="headerlink" title="诞生"></a>诞生</h4><blockquote><p>1994年可以看做前端历史的起点，这一年10月13日网景推出了第一版Navigator；这一年，Tim Berners-Lee创建了W3C；这一年，Tim的基友发布了CSS（层叠样式表）。1995年，当时在<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">网景公司</a>就职的<a href="https://zh.wikipedia.org/wiki/%E5%B8%83%E8%98%AD%E7%99%BB%C2%B7%E8%89%BE%E5%85%8B" target="_blank" rel="noopener">布兰登·艾克</a>正为<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E6%99%AF%E5%AF%BC%E8%88%AA%E8%80%85" target="_blank" rel="noopener">Netscape Navigator</a> 2.0浏览器开发的一门名为LiveScript的脚本语言，后来网景公司与<a href="https://zh.wikipedia.org/wiki/%E6%98%87%E9%99%BD%E9%9B%BB%E8%85%A6" target="_blank" rel="noopener">昇阳</a>电脑公司组成的开发联盟为了让这门语言搭上<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">java</a>这个编程语言“热词”，将其临时改名为“JavaScript”，日后这成为大众对这门语言有诸多误解的原因之一。</p><p>万维网（WWW）是欧洲核子研究组织的一帮科学家为了方便看文档、传论文而创造的，这就是为什么Web网页都基于Document。Document就是用标记语言+超链接写成的由文字和图片构成的HTML页面，这样的功能已经完全满足学术交流的需要，所以网页的早期形态和Document一样，完全基于HTML页面，并且所有内容都是静态的。</p><p>1999年W3C发布第四代HTML标准，同年微软推出用于异步数据传输的ActiveX，随即各大浏览器厂商模仿实现了XMLHttpRequest。这标识着Ajax的诞生，但是Ajax这个词是在六年后问世的，特别是在谷歌使用Ajax技术打造了Gmail和谷歌地图之后，Ajax获得了巨大的关注。Ajax是Web网页迈向Web应用的关键技术，它标识着Web2.0时代的到来。</p><p>2006年，XMLHttpRequest被W3C正式纳入标准。</p><p>至此，早期的Document终于进化为了Web page，上述三个局限都得到了妥善的解决。</p></blockquote><h4 id="远古时代（web-1-0）"><a href="#远古时代（web-1-0）" class="headerlink" title="远古时代（web 1.0）"></a>远古时代（web 1.0）</h4><p>那时候的web开发还属于纯静态开发。开发者在web服务器的指定文件夹(/www)下，放置一下html文件，当浏览器请求的页面的时候返回相应的html文件。</p><p><img src="http://ww1.sinaimg.cn/large/63918611gw1e7ehutyrrnj20hz076dg8.jpg" alt=""></p><p>但是，渐渐的纯静态的页面不足以满足产品的发展需求（例如：统计该网站的访问流量，提交用户的输入信息）。这时候，大约2005年左右，出现了Java Server Pages(JSP)，微软的ASP，以及Ajax！你可以基于jsp和Ajax快速构建一个可伸缩并且安全的应用程序。</p><p><img src="https://github-camo.global.ssl.fastly.net/d0098546c9fa01b443c16ff1953c90aa9056955b/687474703a2f2f696d672e68622e616963646e2e636f6d2f3932393766646337336438336632373764343439633932313933613361663432386464633064343431316366392d6e31445936465f6677363538" alt=""></p><h4 id="石器时代-web-2-0"><a href="#石器时代-web-2-0" class="headerlink" title="石器时代 (web 2.0)"></a>石器时代 (web 2.0)</h4><p>因为当时浏览器厂商的混乱（例如：ie, chrome, firefox等），拥有不同内核的浏览器Trident(IE内核)，Gecko(Firefox 内核)，webkit（Safari 内涵）, Chromium/Blink（Chrome内核），Presto（Opera内核）等。当时的浏览器厂商的标准都不一样。比如写一个点击事件需要做一些兼容性处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e = e || <span class="built_in">window</span>.event <span class="comment">//处理ie浏览器和其他浏览器之间的事件兼容问题</span></span><br></pre></td></tr></table></figure><p>这时候为了处理浏览器的兼容性，出现了YUI 和 jQuery, 主要解决了DOM元素选择，CSS操纵，事件系统处理。同时也可以兼顾一下动画效果的实现和一些常用插件的封装（表单验证，日历插件等）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//jQuery</span></span><br><span class="line">$(<span class="string">"p.surprise"</span>).addClass(<span class="string">"ohmy"</span>).show(<span class="string">"slow"</span>);</span><br><span class="line">$(<span class="string">"p.surprise"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//YUI</span></span><br><span class="line">YUI().use(<span class="string">'node'</span>, <span class="string">'event'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">Y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The Node and Event modules are loaded and ready to use.</span></span><br><span class="line">  <span class="comment">// Your code goes here!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="模块化时代"><a href="#模块化时代" class="headerlink" title="模块化时代"></a>模块化时代</h4><p>最开始JavaScript承担的任务量并不多，表单验证基本上就是他的全部，最多就是简短的前端交互，这个时期JavaScript组织结构非常凌乱，大部分都是后端顺手代劳，那时候还没有“前端”这一职位。 一般都是写到一个文件或者直接写到jsp、asp的后端模板页面上就完事了。随着ajax的流行，前端能做的东西一夜之间暴涨，代码量飞速增加，单文件维护代码已经太沉重，多人开发全局变量泛滥，代码合并引起冲突覆盖等问题。最开始的解决的方式是用匿名函数包裹自己的代码，这样就不会把定义的变量暴露到全局作用域里面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//立即执行函数写法　</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//业务代码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    m1 : m1</span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;)();</span><br><span class="line"><span class="comment">//可以传入参数</span></span><br><span class="line"><span class="keyword">var</span> module1 = (<span class="function"><span class="keyword">function</span> (<span class="params">$, undefined</span>) </span>&#123;</span><br><span class="line">　　<span class="comment">//业务代码</span></span><br><span class="line">&#125;)(jQuery);</span><br><span class="line"><span class="comment">//命名空间方式</span></span><br><span class="line"><span class="keyword">var</span> namespace = &#123;&#125;;</span><br><span class="line">namespace.xxx = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;</span><br></pre></td></tr></table></figure><p>随着网站逐渐的发展，嵌入网页的Javascript代码越来越庞大，而网页越来越像桌面程序，需要一个团队去分工协作，进行管理和测试等等，为了更好的管理网页的业务逻辑，处理代码之间的依赖关系，产生了模块化编程的理念。</p><p>2008年9月2日，Google为旗下浏览器Chrome加入了V8 JavaScript处理引擎，可以更快速，更稳定，更安全的处理JavaScript代码。2009年，Ryan Dahl结合Google的 V8引擎、事件驱动模式、低级I\O接口开发了Node.js。</p><p>2010年1月，一款名为’npm‘的软件包管理系统诞生，随之而来的还有<a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">commonJS 规范</a>。</p><blockquote><ol><li>模块的标识应遵循的规则（书写规范）</li><li>定义全局函数require，通过传入模块标识来引入其他模块，执行的结果即为别的模块暴漏出来的API</li><li>如果被require函数引入的模块中也包含依赖，那么依次加载这些依赖</li><li>如果引入模块失败，那么require函数应该报一个异常</li><li>模块通过变量exports来向往暴漏API，exports只能是一个对象，暴漏的API须作为此对象的属性。</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>, i = <span class="number">0</span>, args = <span class="built_in">arguments</span>, l = args.length;</span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">      sum += args[i++];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//add.js</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="built_in">require</span>(<span class="string">'math'</span>).add;</span><br><span class="line">add(val, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>但是Node.js主要是用于服务器端，无法直接用在浏览器端，主要表现在服务端require一个模块，直接就从硬盘或者内存中读取了，消耗的时间可以忽略。而浏览器则不同，需要从服务端来下载这个文件，然后运行里面的代码才能得到API，需要花费一个http请求，也就是说，require后面的一行代码，需要资源请求完成才能执行。由于浏览器端是以插入<code>&lt;script&gt;</code>标签的形式来加载资源的（ajax方式不行，有跨域问题），没办法让代码同步执行，所以像commonjs那样的写法会直接报错。</p><p>所以，社区意识到，要想在浏览器环境中也能模块化，需要对规范进行升级。而就在社区讨论制定下一版规范的时候，内部发生了比较大的分歧，产生了不同的规范。</p><h5 id="AMD-RequireJs的崛起与妥协"><a href="#AMD-RequireJs的崛起与妥协" class="headerlink" title="AMD/RequireJs的崛起与妥协"></a>AMD/RequireJs的崛起与妥协</h5><blockquote><ol><li>用全局函数define来定义模块，用法为：define(id?, dependencies?, factory);</li><li>id为模块标识，遵从CommonJS Module Identifiers规范</li><li>dependencies为依赖的模块数组，在factory中需传入形参与之一一对应</li><li>如果dependencies的值中有”require”、”exports”或”module”，则与commonjs中的实现保持一致</li><li>如果dependencies省略不写，则默认为[“require”, “exports”, “module”]，factory中也会默认传入require,exports,module</li><li>如果factory为函数，模块对外暴漏API的方法有三种：return任意类型的数据、exports.xxx=xxx、module.exports=xxx</li><li>如果factory为对象，则该对象即为模块的返回值</li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//页面中需要引入require.js</span></span><br><span class="line"><span class="comment">//data-main 的作用是告诉 require.js 加载 main.js的代码.</span></span><br><span class="line"><span class="comment">// &lt;script data-main="scripts/main" src="scripts/require.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">// math.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    add: add</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">math</span>)</span>&#123;</span><br><span class="line">  math.add(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="兼容并包的CMD-seajs"><a href="#兼容并包的CMD-seajs" class="headerlink" title="兼容并包的CMD/seajs"></a>兼容并包的CMD/seajs</h5><p>seajs的作者是国内大牛, 淘宝前端玉伯。</p><blockquote><ol><li>一个文件一个模块，所以经常就用文件名作为模块id</li><li>CMD推崇依赖就近，所以一般不在define的参数中写依赖，在factory中写</li><li>factory是一个函数，有三个参数，function(require, exports, module)<ul><li>require 是一个方法，接受 模块标识 作为唯一参数，用来获取其他模块提供的接口：require(id)</li><li>exports 是一个对象，用来向外提供模块接口</li><li>module 是一个对象，上面存储了与当前模块相关联的一些属性和方法</li></ul></li></ol></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"sea.js"</span> data-main=<span class="string">"main.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="comment">//main.js</span></span><br><span class="line">seajs.use([<span class="string">'./hello'</span>, <span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">hello, $</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">'#beautiful-sea'</span>).click(hello.sayHello);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//hello</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'#hello'</span>).toggle(<span class="string">'slow'</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>AMD与CMD区别主要是：</p><ol><li>AMD推崇依赖前置，在定义模块的时候就要声明其依赖的模块</li><li>CMD推崇就近依赖，只有在用到某个模块的时候再去require</li></ol><h5 id="面向未来的ES6模块标准"><a href="#面向未来的ES6模块标准" class="headerlink" title="面向未来的ES6模块标准"></a>面向未来的ES6模块标准</h5><p>ECMAScript是由ECMA-262标准化的脚本语言的名称。JavaScript和JScript与ECMAScript兼容，但包含超出ECMAScript的功能。ECMA-262的第一个版本于1997年6月被Ecma组织采纳。</p><p>2011 年，ECMAScript 5.1(ES5) 版发布。也是前端快速发展的一段时间。上面大部分模块解决方案，jQuery等框架都是基于ECMAScript 5.1规范开发的。2015 年，负责制定 ECMAScript 规范草案的委员会决定将定义新标准的制度改为一年一次。ES6的第一个版本在2015 年 6 月发布，正式名称就是《ECMAScript 2015 标准》（简称 ES2015/ES6），2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016/ES7），2017年6月，《ECMAScript 2017 标准》（简称 ES2017/ES8）。我们统一把ECMAScript 2015标准之后的版本称为<strong>ES6</strong>.</p><p>模块功能主要由两个命令构成：<code>export</code> 和 <code>import</code>。<code>export</code>命令用于规定模块的对外接口，<code>import</code>命令用于输入其他模块提供的功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">'./math'</span>;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>但是由于ES6的标准太超前，浏览器的更新无法跟上，所以还不能直接应用到浏览器里面。通过Babel 语法转换器在本地编译成浏览器可识别的ES5代码。</p><h3 id="未来"><a href="#未来" class="headerlink" title="未来"></a>未来</h3><p>前端发展到模块化时代变得越来正规，团队之间的配合也越来越重，遇到的问题越来越多，通过借鉴传统的后端开发模式，衍生出了自己的JavaScript设计模式（单例模式，观察者模式，原型模式等），也有了自己的架构模式（MVC，MVVM，MVP）。</p><p>根据不同的设计模式有出现了不同的前端框架(Ext JS, jQuery UI, jQuery Mobile, Dojo, Prototype JS, Kissy, React, Vue,  Angular等) 。</p><p>既然JavaScript出现了各种不同的模块解决方案，CSS也需要跟上JavaScript模块化进程（Sass, Less, Stylus）。</p><p>HTML也出现了各种模版系统（Handlebars，EJS等）。</p><p>各种编译工具（grunt, gulp, webpack等）。</p><p>最后, 我们期待无法预测的未来。</p><blockquote><p>It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.</p><p>那是最好的時代，那是最壞的時代；那是智慧的歲月，那是愚昧的歲月；那是信任的紀元，那是懷疑的紀元；那是光明的季節，那是黑暗的季節；那是希望的春天，那是失望的冬天；我們的前面曾應有盡有，我們的前面曾一無所有；我們都將走上天堂，我們都將走向另一端–簡言之，那段時期與現在的時期是那麼相似，那些最吵雜的權威人士都堅持，不論是善良或邪惡，用最高級形容詞來評論。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么是前端&quot;&gt;&lt;a href=&quot;#什么是前端&quot; class=&quot;headerlink&quot; title=&quot;什么是前端&quot;&gt;&lt;/a&gt;什么是前端&lt;/h5&gt;&lt;p&gt;前端工程师主要利用HMTL与CSS构建页面，用JavaScript完善交互以及用户体验。&lt;/p&gt;
&lt;h4 id=&quot;诞
      
    
    </summary>
    
      <category term="Notes" scheme="http://hero-guo.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数据去重</title>
    <link href="http://hero-guo.com/2017/11/06/arr-uniq/"/>
    <id>http://hero-guo.com/2017/11/06/arr-uniq/</id>
    <published>2017-11-05T16:00:00.000Z</published>
    <updated>2017-11-06T09:29:17.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="只包含原始变量-不会判断值的类型"><a href="#只包含原始变量-不会判断值的类型" class="headerlink" title="只包含原始变量, 不会判断值的类型"></a>只包含原始变量, 不会判断值的类型</h4><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'a'</span> ];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">v, i</span>) =&gt;</span> arr.indexOf(v) === i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq(array)); <span class="comment">//=&gt; [1, 'a']</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'a'</span> ];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));</span><br><span class="line"><span class="comment">//return [...new Set(arr)]; </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq(array)); <span class="comment">//=&gt; [1, 'a']</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'a'</span> ];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = [];</span><br><span class="line">  <span class="keyword">const</span> len = arr.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!~res.indexOf(arr[i])) res.push(arr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq(array)); <span class="comment">//=&gt; [1, 'a']</span></span><br></pre></td></tr></table></figure><h4 id="包含引用类型"><a href="#包含引用类型" class="headerlink" title="包含引用类型"></a>包含引用类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, [ <span class="number">1</span>, <span class="number">2</span> ], [ <span class="number">1</span>, <span class="number">2</span> ]];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> hash = &#123;&#125;;</span><br><span class="line"> <span class="keyword">return</span> arr.filter(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> key = <span class="built_in">JSON</span>.stringify(v);</span><br><span class="line">   <span class="keyword">const</span> bool = !!hash[key];</span><br><span class="line">   <span class="keyword">return</span> bool ? <span class="literal">false</span> : hash[key] = <span class="literal">true</span>;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq(array)); <span class="comment">//=&gt; [&#123; a: 1 &#125;, [ 1, 2 ]]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;只包含原始变量-不会判断值的类型&quot;&gt;&lt;a href=&quot;#只包含原始变量-不会判断值的类型&quot; class=&quot;headerlink&quot; title=&quot;只包含原始变量, 不会判断值的类型&quot;&gt;&lt;/a&gt;只包含原始变量, 不会判断值的类型&lt;/h4&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="数据去重" scheme="http://hero-guo.com/tags/%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数据结构与算法 —— 栈</title>
    <link href="http://hero-guo.com/2017/09/09/javascript-%E2%80%94%E2%80%94-%E6%A0%88/"/>
    <id>http://hero-guo.com/2017/09/09/javascript-——-栈/</id>
    <published>2017-09-09T07:04:20.000Z</published>
    <updated>2018-07-11T13:37:05.847Z</updated>
    
    <content type="html"><![CDATA[<p>最近看了一本《学习JavaScript数据结构与算法》，想把里面介绍的一些数据结构和算法记录下来，加深印象。</p><blockquote><p>栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾。称作栈顶，另一端就叫栈底。在栈里，新元素都靠近栈顶，就元素都接近栈底。</p></blockquote><p>在JavaScript里面数组的一些方法可以很好的模拟栈。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *用JavaScript数组模拟栈</span></span><br><span class="line"><span class="comment"> *@class Stack</span></span><br><span class="line"><span class="comment"> *@constructor</span></span><br><span class="line"><span class="comment"> *@method</span></span><br><span class="line"><span class="comment"> ** push(element) 添加一个或多个新元素到栈顶</span></span><br><span class="line"><span class="comment"> ** pop() 移除栈顶的元素，同时返回被移除的新元素</span></span><br><span class="line"><span class="comment"> ** peek() 返回栈顶元素，不对栈做任何修改</span></span><br><span class="line"><span class="comment"> ** isEmpty() 返回ture(栈为空) 和 false(非空)</span></span><br><span class="line"><span class="comment"> ** clear() 移除栈里的所有元素</span></span><br><span class="line"><span class="comment"> ** size() 返回栈里元素的个数</span></span><br><span class="line"><span class="comment"> ** print() 输出栈</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> items = []; <span class="comment">//保存栈里的元素</span></span><br><span class="line">  <span class="keyword">this</span>.push = <span class="function"><span class="keyword">function</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    items.push(element);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.pop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.peek = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items[items.length - <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.isEmpty = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.clear = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    items = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.size = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> items.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(items.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上就是一个栈的实现。现在我们来看看怎么使用它。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line"><span class="comment">//往栈里添加些元素</span></span><br><span class="line">stack.push(<span class="number">3</span>);</span><br><span class="line">stack.push(<span class="number">4</span>);</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()); <span class="comment">// =&gt; false</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.size()); <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.peek()); <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.print()); <span class="comment">// =&gt; '3,4'</span></span><br><span class="line"></span><br><span class="line">stack.pop();</span><br><span class="line"><span class="built_in">console</span>.log(stack.print()); <span class="comment">// =&gt; 3</span></span><br><span class="line"></span><br><span class="line">stack.clear()</span><br><span class="line"><span class="built_in">console</span>.log(stack.isEmpty()); <span class="comment">// =&gt; true</span></span><br><span class="line"><span class="built_in">console</span>.log(stack.print()); <span class="comment">// =&gt; ''</span></span><br></pre></td></tr></table></figure></p><h6 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h6><p>进制转换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseConverter</span>(<span class="params">num, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> stack = <span class="keyword">new</span> Stack(),</span><br><span class="line">      base = base || <span class="number">2</span>,</span><br><span class="line">      rem,</span><br><span class="line">      digits = <span class="string">'0123456789ABCDEF'</span>,</span><br><span class="line">      baseString = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    rem = <span class="built_in">Math</span>.floor(num % base);</span><br><span class="line">    stack.push(rem);</span><br><span class="line">    num = <span class="built_in">Math</span>.floor(num / base);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">    baseString += digits[stack.pop()];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> baseString;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(baseConverter(<span class="number">100</span>)); <span class="comment">//=&gt; 1100100</span></span><br><span class="line"><span class="built_in">console</span>.log(baseConverter(<span class="number">100</span>, <span class="number">8</span>)); <span class="comment">//=&gt; 144</span></span><br><span class="line"><span class="built_in">console</span>.log(baseConverter(<span class="number">100</span>, <span class="number">16</span>)); <span class="comment">//=&gt; 64</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看了一本《学习JavaScript数据结构与算法》，想把里面介绍的一些数据结构和算法记录下来，加深印象。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;栈是一种遵从后进先出（LIFO）原则的有序集合。新添加的或待删除的元素都保存在栈的末尾。称作栈顶，另一端就叫栈底。在栈里，新
      
    
    </summary>
    
      <category term="Notes" scheme="http://hero-guo.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="数据结构与算法" scheme="http://hero-guo.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 面向对象</title>
    <link href="http://hero-guo.com/2017/04/11/JavaScript-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://hero-guo.com/2017/04/11/JavaScript-面向对象/</id>
    <published>2017-04-11T03:05:34.000Z</published>
    <updated>2017-08-30T14:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数也是一个函数，通过new运算符可以生成一份实例同时把this绑定到实例上。JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span> (<span class="params">engines</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.engines = engines;</span><br><span class="line">  &#125;</span><br><span class="line">  Vehicle.prototype.drive = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`engines=&gt;<span class="subst">$&#123;<span class="keyword">this</span>.engines&#125;</span>`</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//实例</span></span><br><span class="line">  <span class="keyword">var</span> car1 = <span class="keyword">new</span> Vehicle(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">var</span> car2 = <span class="keyword">new</span> Vehicle(<span class="number">2</span>);</span><br><span class="line">  car1.drive(); <span class="comment">//=&gt; engines=&gt;1</span></span><br><span class="line">  car2.drive(); <span class="comment">//=&gt; engines=&gt;2</span></span><br><span class="line">  <span class="built_in">console</span>.log(car1.constructor === Vehicle); <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(car2.constructor === Vehicle); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><p>instanceof是一个操作符，可以判断对象是否为某个类型的实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(car1 <span class="keyword">instanceof</span> Vehicle); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(car2 <span class="keyword">instanceof</span> Vehicle); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>instanceof判断的是对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p><p>isPrototypeOf用来判断proptotype对象和实例之间的关系<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Vehicle.prototype.isPrototypeOf(car1)); <span class="comment">//true</span></span><br><span class="line">  <span class="built_in">console</span>.log(Vehicle.prototype.isPrototypeOf(car2)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><p>hasOwnProperty()可以判断一个对象是否包含自定义属性而不是原型链上的属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(car1.hasOwnProperty(<span class="string">'engines'</span>)); <span class="comment">//true</span></span><br><span class="line"> <span class="built_in">console</span>.log(car1.hasOwnProperty(<span class="string">'drive'</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;构造函数&quot;&gt;&lt;a href=&quot;#构造函数&quot; class=&quot;headerlink&quot; title=&quot;构造函数&quot;&gt;&lt;/a&gt;构造函数&lt;/h3&gt;&lt;p&gt;构造函数也是一个函数，通过new运算符可以生成一份实例同时把this绑定到实例上。JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Vehicle&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;engines&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.engines = engines;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Vehicle.prototype.drive = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`engines=&amp;gt;&lt;span class=&quot;subst&quot;&gt;$&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.engines&amp;#125;&lt;/span&gt;`&lt;/span&gt;);    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//实例&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; car1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vehicle(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; car2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vehicle(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  car1.drive(); &lt;span class=&quot;comment&quot;&gt;//=&amp;gt; engines=&amp;gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  car2.drive(); &lt;span class=&quot;comment&quot;&gt;//=&amp;gt; engines=&amp;gt;2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(car1.constructor === Vehicle); &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(car2.constructor === Vehicle); &lt;span class=&quot;comment&quot;&gt;//true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>promise.all错误处理</title>
    <link href="http://hero-guo.com/2017/03/13/promise-all/"/>
    <id>http://hero-guo.com/2017/03/13/promise-all/</id>
    <published>2017-03-13T13:15:15.000Z</published>
    <updated>2017-08-30T15:38:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>通常处理多个请求的时候我们会用Promise.all()方法。该方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。但是当其中任何一个被拒绝的话。主Promise.all([..])就会立即被拒绝，并丢弃来自其他所有promis的全部结果。<br><a id="more"></a><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">"foo"</span>);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// 永远走不到这里</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这不是我们想要的。所以在使用这个方法的时候要记住为每个promise关联一个错误的处理函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="built_in">Promise</span>.reject(<span class="number">2</span>).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(resolve, <span class="number">100</span>, <span class="string">"foo"</span>);</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all([p1, p2, p3]).then(<span class="function"><span class="params">values</span> =&gt;</span> &#123; </span><br><span class="line">  <span class="built_in">console</span>.log(values); <span class="comment">// [3, 2, "foo"]</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">//不会走到这里</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常处理多个请求的时候我们会用Promise.all()方法。该方法指当所有在可迭代参数中的 promises 已完成，或者第一个传递的 promise（指 reject）失败时，返回 promise。但是当其中任何一个被拒绝的话。主Promise.all([..])就会立即被拒绝，并丢弃来自其他所有promis的全部结果。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>函数柯里化</title>
    <link href="http://hero-guo.com/2017/02/27/curry/"/>
    <id>http://hero-guo.com/2017/02/27/curry/</id>
    <published>2017-02-27T03:27:55.000Z</published>
    <updated>2017-08-30T14:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数柯里化定义"><a href="#函数柯里化定义" class="headerlink" title="函数柯里化定义"></a>函数柯里化定义</h3><p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p><h3 id="函数柯理化实现"><a href="#函数柯理化实现" class="headerlink" title="函数柯理化实现"></a>函数柯理化实现</h3><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> autocurry = <span class="function"><span class="keyword">function</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> numargs = fn.length;</span><br><span class="line">  <span class="keyword">return</span> createRecurser([]);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">createRecurser</span> (<span class="params">acc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">      <span class="keyword">return</span> recurse(acc, args);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recurse</span> (<span class="params">acc, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> newacc = acc.concat(args);</span><br><span class="line">    <span class="keyword">if</span> (newacc.length &lt; numargs) &#123;</span><br><span class="line">      <span class="keyword">return</span> createRecurser(newacc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, newacc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> add = autocurry(<span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>,<span class="number">2</span>)); =&gt; <span class="number">3</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">1</span>)(<span class="number">3</span>)); =&gt; <span class="number">4</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;函数柯里化定义&quot;&gt;&lt;a href=&quot;#函数柯里化定义&quot; class=&quot;headerlink&quot; title=&quot;函数柯里化定义&quot;&gt;&lt;/a&gt;函数柯里化定义&lt;/h3&gt;&lt;p&gt;柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。&lt;/p&gt;
&lt;h3 id=&quot;函数柯理化实现&quot;&gt;&lt;a href=&quot;#函数柯理化实现&quot; class=&quot;headerlink&quot; title=&quot;函数柯理化实现&quot;&gt;&lt;/a&gt;函数柯理化实现&lt;/h3&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="柯里化" scheme="http://hero-guo.com/tags/%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 事件详解</title>
    <link href="http://hero-guo.com/2017/02/13/javascript-event/"/>
    <id>http://hero-guo.com/2017/02/13/javascript-event/</id>
    <published>2017-02-13T03:17:33.000Z</published>
    <updated>2018-07-11T13:37:09.254Z</updated>
    
    <content type="html"><![CDATA[<h3 id="事件冒泡与捕获"><a href="#事件冒泡与捕获" class="headerlink" title="事件冒泡与捕获"></a>事件冒泡与捕获</h3><ol><li><p>冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。<br>IE 5.5: div -&gt; body -&gt; document<br>IE 6.0: div -&gt; body -&gt; html -&gt; document<br>Mozilla 1.0: div -&gt; body -&gt; html -&gt; document -&gt; window</p></li><li><p>捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。</p></li><li>DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。<br>DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。<a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>这两个元素都绑定了click事件，如果用户点击了p，它在div和p上都触发了click事件，那这两个事件处理程序哪个先执行呢？事件顺序是什么？</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p>当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。</p><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p>当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。</p><h5 id="W3C模型"><a href="#W3C模型" class="headerlink" title="W3C模型"></a>W3C模型</h5><p>W3C模型是将两者进行中和，在W3C模型中，任何事件发生时，先从顶层开始进行事件捕获，直到事件触发到达了事件源元素。然后，再从事件源往上进行事件冒泡，直到到达document。</p><p>程序员可以自己选择绑定事件时采用事件捕获还是事件冒泡，方法就是绑定事件时通过addEventListener函数，它有三个参数，type, listener[, options]。第一个参数表示监听事件类型的字符串。第二个参数当所监听的事件类型触发时，会接收到一个事件通知（实现了 Event 接口的对象）对象。listener 必须是一个实现了 EventListener 接口的对象，或者是一个函数。第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡<br>ele.addEventListener(‘click’,doSomething,true)<br>true=捕获<br>false=冒泡</p><h5 id="IE"><a href="#IE" class="headerlink" title="IE"></a>IE</h5><p>IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ele.attachEvent(<span class="string">"onclick"</span>, doSomething);</span><br></pre></td></tr></table></figure></p><p>事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p><p>至此我们可以封装一下事件绑定的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//事件绑定</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">target, type, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target.addEventListener) &#123;</span><br><span class="line">    target.addEventListener(type, func, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.attachEvent) &#123;</span><br><span class="line">    target.attachEvent(<span class="string">'on'</span> + type, func);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target[<span class="string">'on'</span> + type] = func;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//事件移除</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">removeEvent</span>(<span class="params">target, type, func</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target.removeEventListener) &#123;</span><br><span class="line">    target.removeEventListener(type, func, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target.detachEvent) &#123;</span><br><span class="line">    target.detachEvent(<span class="string">'on'</span> + type, func);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target[<span class="string">'on'</span> + type] = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="事件的传播是可以阻止的："><a href="#事件的传播是可以阻止的：" class="headerlink" title="事件的传播是可以阻止的："></a>事件的传播是可以阻止的：</h3><p>阻止事件冒泡<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">  event.stopPropagation();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  event.cancelBubble = <span class="literal">true</span>; <span class="comment">// 兼容IE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>阻止事件的默认行为<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">  event.preventDefault(); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  event.returnValue = <span class="literal">false</span>; <span class="comment">// 兼容IE</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。有点就是可以提高性能。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">'ul'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">'ul'</span>);</span></span><br><span class="line"><span class="javascript">    addEvent(oUl, <span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> target = ev.target || ev.srcElement;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (targe.nodeName.toLowerCase() === <span class="string">'li'</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(target.innerHTML);</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="JS观察者模式"><a href="#JS观察者模式" class="headerlink" title="JS观察者模式"></a>JS观察者模式</h3><p>这是一种创建松散耦合代码的技术。它定义对象间 一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。由主体和观察者组成，主体负责发布事件，同时观察者通过订阅这些事件来观察该主体。主体并不知道观察者的任何事情，观察者知道主体并能注册事件的回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> handlers = &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">on</span>(<span class="params">evt, func</span>) </span>&#123;</span><br><span class="line">        handlers[evt] = handlers[evt] || [];</span><br><span class="line">        handlers[evt].push(func);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">once</span>(<span class="params">evt, func</span>) </span>&#123;</span><br><span class="line">        handlers[evt] = [];</span><br><span class="line">        handlers[evt].push(func);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">off</span>(<span class="params">evt, func</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> handler = handlers[evt];</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handler.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler[i] === func) &#123;</span><br><span class="line">              handler.splice(i, <span class="number">1</span>);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">emit</span>(<span class="params">evt, arg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handlers[evt]) &#123;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; handlers[evt].length; i++) &#123;</span><br><span class="line">            handlers[evt][i](arg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        on: on,</span><br><span class="line">        once: once,</span><br><span class="line">        off: off,</span><br><span class="line">        emit: emit,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;)();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;事件冒泡与捕获&quot;&gt;&lt;a href=&quot;#事件冒泡与捕获&quot; class=&quot;headerlink&quot; title=&quot;事件冒泡与捕获&quot;&gt;&lt;/a&gt;事件冒泡与捕获&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。&lt;br&gt;IE 5.5: div -&amp;gt; body -&amp;gt; document&lt;br&gt;IE 6.0: div -&amp;gt; body -&amp;gt; html -&amp;gt; document&lt;br&gt;Mozilla 1.0: div -&amp;gt; body -&amp;gt; html -&amp;gt; document -&amp;gt; window&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。&lt;br&gt;DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="事件" scheme="http://hero-guo.com/tags/%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>充分理解闭包</title>
    <link href="http://hero-guo.com/2017/02/12/closure/"/>
    <id>http://hero-guo.com/2017/02/12/closure/</id>
    <published>2017-02-12T06:57:15.000Z</published>
    <updated>2017-08-30T15:35:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="闭包定义"><a href="#闭包定义" class="headerlink" title="闭包定义"></a>闭包定义</h3><ul><li>函数定义时的作用域链到函数执行时依然有效</li><li>函数体内部到变量都可以保存在函数作用域内</li><li>闭包可以访问它被创建时候到上下文环境</li></ul><a id="more"></a><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>由于闭包是基于词法作用域书写代码时所产生到自然结果，所以为了理解闭包，我们先来看看什么是词法作用域。</p><h5 id="什么是词法作用域？"><a href="#什么是词法作用域？" class="headerlink" title="什么是词法作用域？"></a>什么是词法作用域？</h5><p>大部分标准语言编译器到第一个工作阶段叫做词法化。简单的说词法作用域就是定义在词法阶段到作用域（也就是说函数声明的位置）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = a * <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">c</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  bar(b * <span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>); <span class="comment">//=&gt; 2, 4, 12</span></span><br></pre></td></tr></table></figure><p>在上面到代码中有3个逐级嵌套到作用域。</p><ol><li>包含着整个全局作用域，其中只有一个标识符： foo；</li><li>包含foo所创建到作用域，其中有三个标识符：a、bar、b；</li><li>包含bar所创建到作用域，其中有一个标识符：c。</li></ol><p>在引擎执行console.log(…)声明，并查找a、b、c三个变量到引用时。首先从最内部到作用域也就是bar()函数作用域开始查找。引擎无法找到a就会继续向上查找也就是foo()函数作用域。在这里找到来a。对于b来讲也是一样的。作用域查找会在找到第一个匹配的标识符时停止。</p><h5 id="闭包的产生"><a href="#闭包的产生" class="headerlink" title="闭包的产生"></a>闭包的产生</h5><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前的词法作用域之外执行。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> baz = foo();</span><br><span class="line">baz(); <span class="comment">// =&gt; 2   这就是闭包</span></span><br></pre></td></tr></table></figure></p><p>函数bar的词法作用域能够访问foo的内部作用域。然后我们返回bar本身。当foo执行后，其返回值（也就是bar函数）赋值给变量baz并调用baz，实际上只是通过不同的标识符引用了内部的函数bar。虽然bar是在定义的词法作用域以外被调用，但是闭包可以访问它被创建时候到上下文环境，所以还是可以访问到变量a。这是为什么呢？</p><p>在foo执行之后。通常foo到整个内部作用域都会被销毁，因为引擎有垃圾回收机制用来释放不在使用到内存空间。但是因为bar声明在foo的内部，它拥有涵盖foo内部作用域的闭包，是的该作用域一直存在，并被bar随时引用。</p><p>无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">  &#125;</span><br><span class="line">  bar(baz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  fn(); <span class="comment">//闭包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="随处可见到闭包"><a href="#随处可见到闭包" class="headerlink" title="随处可见到闭包"></a>随处可见到闭包</h5><p>你已经写过到代码中一定到处都是闭包到影子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(message);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="string">'Hello, closure'</span>);</span><br></pre></td></tr></table></figure></p><p>wait执行1000毫秒后，它到内部作用域并不会消失，timer函数依然可以访问它内部到变量message。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name, selector</span>) </span>&#123;</span><br><span class="line">  $(selector).click(<span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Activating:'</span> + name);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">setupBot(<span class="string">'Closure Bot 1'</span>, <span class="string">'#bot1'</span>);</span><br></pre></td></tr></table></figure></p><p>本质上无论何时何地。如果将函数当作第一级到值类型并到处传递，你就会看到闭包了。</p><h5 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码期望是输出1～5，每秒一次，每次一个。但是实际上是每秒一次输出到都是6。这是为什么呢？</p><p>原来循环中定义的函数都共享一个全局作用域，因此实际上只有一个i。因此我们需要更多的闭包作用域，特别是循环过程中每个迭代都需要一个闭包作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, j*<span class="number">1000</span>)</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用let可以有更简单都写法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, i*<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是因为let每次迭代都会重新声明一个作用域。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《你不知道的javascript上》</p><p>《javascript权威指南》</p><p>《javascript高级程序设计》</p><p>《javascript语言精粹》</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;闭包定义&quot;&gt;&lt;a href=&quot;#闭包定义&quot; class=&quot;headerlink&quot; title=&quot;闭包定义&quot;&gt;&lt;/a&gt;闭包定义&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;函数定义时的作用域链到函数执行时依然有效&lt;/li&gt;
&lt;li&gt;函数体内部到变量都可以保存在函数作用域内&lt;/li&gt;
&lt;li&gt;闭包可以访问它被创建时候到上下文环境&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Notes" scheme="http://hero-guo.com/categories/Notes/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="闭包" scheme="http://hero-guo.com/tags/%E9%97%AD%E5%8C%85/"/>
    
  </entry>
  
  <entry>
    <title>类的继承</title>
    <link href="http://hero-guo.com/2017/02/12/object-prototype/"/>
    <id>http://hero-guo.com/2017/02/12/object-prototype/</id>
    <published>2017-02-12T06:57:15.000Z</published>
    <updated>2017-08-30T14:28:05.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>混合复制</p><pre><code>//复制source对象的属性function mixin(source, target) {    for (var key in source) {        if (!(key in target)) {            target[key] = source[key];        }    }    return target;}var Vehicle = {    engines: 1,    ignition: function() {        console.log(&quot; Turning on my forward! &quot;);    },    drive: function() {        this.ignition();        console.log(&quot; Steering and moving forward! &quot;);    }};//Car复制Vehicle的属性值和函数引用var Car = mixin(Vehicle, {    wheels: 4,    drive: function() {    //显示指定Vehicle对象调用dirve方法    //如果直接执行Vehicle.dirve()，函数调用中的this就会绑定到Vehicle上，所以使用.call(this)来确保dirve在Car对象的上下文中执行;    Vehicle.drive.call(this);        console.log(&quot; Rolling on all &quot; + this.wheels + &quot;wheels!&quot;);    }});Car.drive();</code></pre><a id="more"></a></li><li><p>寄生继承<br> 首先复制一份父类（Vehicle），然后混入子类（Car）。然后构建实例。</p><pre><code>//类function Vehicle() {    this.engines = 1;}Vehicle.prototype.ignition = function() {    console.log(&quot; Turning on my forward! &quot;);};Vehicle.prototype.drive = function() {    this.ignition();    console.log(&quot; Steering and moving forward! &quot;);};//寄生类Carfunction Car() {    //car 是一个Vehicle    var car = new Vehicle();    car.wheels = 4;    //保存Vehicle::drive()的特殊引用    var vehDrive = car.drive;    //重写Vehicle::drive()    car.drive = function() {        vehDrive.call(this);        console.log(&quot; Rolling on all &quot; + this.wheels + &quot;wheels!&quot;);    }    return car;}// 因为没使用new创建的新对象而是使用返回的car，所以可以直接调用Car();//var myCar = Car();var myCar = new Car();myCar.drive();</code></pre></li></ol><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><pre><code>function Foo(name) {    this.name = name;}Foo.prototype.myName = function() {    return this.name;}function Bar(name, label) {    Foo.call(this, name);    this.label = label;}//Bar.prototype 关联到 Foo.prototype//调用Object.create()创建一个新对象并把内部的[[prototype]]关联到指定的对象（Foo.prototype）//ES6直接修改现有的Bar.prototype  //Object.setPrototypeOf(Bar.prototype, Foo.prototype);Bar.prototype = Object.create(Foo.prototype);Bar.prototype.constructor = Bar;Bar.prototype.myLabel = function() {    return this.label;}var a = new Bar(&apos;a&apos;, &apos;obj a&apos;);</code></pre><p><code>Bar.prototype = Foo.prototype</code> 并不会创建一个关联到Bar.prototype的新对象，只是直接引用Foo.prototype对象。因此执行复制语句可能会修改Foo.prototype本身。<br><code>Bar.prototype = new Foo()</code>虽然会创建一个关联到Bar.prototype的新对象，但是他使用的是new Foo()构造函数调用，如果Foo函数有一些副作用可能会影响到Bar()的后代。</p>]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;混合复制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;//复制source对象的属性
function mixin(source, target) {
    for (var key in source) {
        if (!(key in target)) {
            target[key] = source[key];
        }
    }
    return target;
}

var Vehicle = {
    engines: 1,
    ignition: function() {
        console.log(&amp;quot; Turning on my forward! &amp;quot;);
    },
    drive: function() {
        this.ignition();
        console.log(&amp;quot; Steering and moving forward! &amp;quot;);
    }
};

//Car复制Vehicle的属性值和函数引用
var Car = mixin(Vehicle, {
    wheels: 4,
    drive: function() {
    //显示指定Vehicle对象调用dirve方法
    //如果直接执行Vehicle.dirve()，函数调用中的this就会绑定到Vehicle上，所以使用.call(this)来确保dirve在Car对象的上下文中执行;
    Vehicle.drive.call(this);
        console.log(&amp;quot; Rolling on all &amp;quot; + this.wheels + &amp;quot;wheels!&amp;quot;);
    }
});
Car.drive();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="继承" scheme="http://hero-guo.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>ES6-MIXIN</title>
    <link href="http://hero-guo.com/2016/12/11/ES6-mixin/"/>
    <id>http://hero-guo.com/2016/12/11/ES6-mixin/</id>
    <published>2016-12-11T06:57:15.000Z</published>
    <updated>2018-07-11T15:34:09.631Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//通过class实现混入</span></span><br><span class="line"><span class="comment">//extends 可以继承动态构造的类</span></span><br><span class="line"><span class="keyword">const</span> Mixin = <span class="function"><span class="params">Sup</span> =&gt;</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">Sup</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="comment">//this关键字则代表实例对象</span></span><br><span class="line">    <span class="keyword">constructor</span>(...args) &#123;</span><br><span class="line">        <span class="comment">//（1）作为函数调用时（即super(...args)），super代表父类的构造函数。</span></span><br><span class="line">        <span class="comment">//（2）作为对象调用时（即super.prop或super.method()），super代表父类。注意，此时super即可以引用父类实例的属性和方法，也可以引用父类的静态方法。</span></span><br><span class="line">        <span class="keyword">super</span>(...args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(width, height, $elem) &#123;</span><br><span class="line">        <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;</span><br><span class="line">            width,</span><br><span class="line">            height,</span><br><span class="line">            $elem: <span class="literal">null</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render($where) &#123;</span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>.$elem) &#123;</span><br><span class="line">             <span class="keyword">this</span>.$elem.css(&#123;</span><br><span class="line">             width: <span class="keyword">this</span>.width + <span class="string">'px'</span>,</span><br><span class="line">             height: <span class="keyword">this</span>.height + <span class="string">'px'</span></span><br><span class="line">            &#125;).appendTo($where);</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">Mixin</span>(<span class="title">Widget</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width, height, label)&#123;</span><br><span class="line">    <span class="keyword">super</span>(width, height);</span><br><span class="line">    <span class="keyword">this</span>.label = label;</span><br><span class="line">    <span class="keyword">this</span>.$elem = $(<span class="string">'&lt;button&gt;'</span>).text(<span class="keyword">this</span>.label);</span><br><span class="line">  &#125;</span><br><span class="line">  render($where) &#123;</span><br><span class="line">    <span class="keyword">super</span>.render($where);</span><br><span class="line">    <span class="keyword">this</span>.$elem.click(<span class="keyword">this</span>.onClick);</span><br><span class="line">  &#125;</span><br><span class="line">  onClick() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Button'</span> + <span class="keyword">this</span>.label + <span class="string">'clicked!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> $body = $(<span class="built_in">document</span>.body) || <span class="built_in">document</span>.body;</span><br><span class="line"><span class="keyword">let</span> btn = <span class="keyword">new</span> Button(<span class="number">125</span>, <span class="number">30</span>, <span class="string">'hello world'</span>);</span><br><span class="line">btn.render($body);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://hero-guo.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://hero-guo.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://hero-guo.com/tags/ES6/"/>
    
  </entry>
  
</feed>
